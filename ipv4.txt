IPV4

id: Identification of the IPv4 header. The id field is important for fragmentation: when
fragmenting an SKB, the id value of all the fragments of that SKB should be the same.
Reassembling fragmented packets is done according to the id of the fragments.


frag_off: The fragment offset, a 16-bit field. The lower 13 bits are the offset of the fragment.
In the first fragment, the offset is 0. The offset is measured in units of 8 bytes. The higher 3 bits
are the flags:
‚Ä¢001 is MF (More Fragments). It is set for all fragments, except the last one.
‚Ä¢010 is DF (Don‚Äôt Fragment).
‚Ä¢100 is CE (Congestion).
See the IP_MF, IP_DF, and IP_CE flags declaration in include/net/ip.h.

ttl: Time To Live: this is a hop counter. Each forwarding node decreases the ttl by 1. When
it reaches 0, the packet is discarded, and a time exceeded ICMPv4 message is sent back; this
avoids packets from being forwarded endlessly, for this reason or another.


The **Type of Service (ToS)** field in the IPv4 header specifies **how the packet should be handled** by routers‚Äîits priority, delay requirements, throughput needs, reliability, etc.

Originally, ToS was an 8-bit field, but it has evolved over time.
Let‚Äôs go through both the **old interpretation** and the **modern one (DSCP/ECN)**.

---

# ‚úÖ **Original IPv4 Type of Service (RFC 791)**

This is the classical structure:

```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   PRECEDENCE   |D|T|R|0|0|0|
+---+---+---+---+---+---+---+---+
```

### 1) **3-bit Precedence**

Indicates priority of the datagram.

| Value | Meaning              |
| ----- | -------------------- |
| 000   | Routine              |
| 001   | Priority             |
| 010   | Immediate            |
| 011   | Flash                |
| 100   | Flash Override       |
| 101   | CRITIC/ECP           |
| 110   | Internetwork Control |
| 111   | Network Control      |

Higher value = higher priority.

---

### 2) **D, T, R flags (1 bit each)**

| Bit | Meaning     | What it asks routers to do |
| --- | ----------- | -------------------------- |
| D   | Delay       | Prefer low delay           |
| T   | Throughput  | Prefer high throughput     |
| R   | Reliability | Prefer high reliability    |

Only one of these was supposed to be set at once.

---

### 3) Last 3 bits: Always zero (unused)

---

# ‚ùå This original ToS is **obsolete**

Routers do NOT use these bits anymore.
Instead, they use the **DSCP/ECN** interpretation defined in RFC 2474 and RFC 3168.

---

# üü© Modern meaning of the Type of Service byte

The 8-bit ToS field was **redefined**:

```
+-----------------------+------------+
|        DSCP (6 bits)  |  ECN (2 bits) |
+-----------------------+------------+
```

---

# ‚úÖ **1. DSCP (Differentiated Services Code Point) ‚Äì 6 bits**

Used for **QoS (Quality of Service)** classification.
Routers use DSCP to decide queueing, scheduling, and priority.

Example DSCP values:

| DSCP (bits) | Name                      | Purpose                    |
| ----------- | ------------------------- | -------------------------- |
| 000000      | BE (Best Effort)          | Normal traffic             |
| 101110      | EF (Expedited Forwarding) | Low loss, low delay (VoIP) |
| 001010      | AF11                      | Assured Forwarding         |
| 010010      | AF21                      | Assured Forwarding         |
| 011010      | AF31                      | Assured Forwarding         |

---

# ‚úÖ **2. ECN (Explicit Congestion Notification) ‚Äì 2 bits**

Used for **active congestion control** without dropping packets.

| ECN bits | Meaning                |
| -------- | ---------------------- |
| 00       | Not ECN-capable        |
| 01       | ECN-capable transport  |
| 10       | ECN-capable transport  |
| 11       | Congestion encountered |

TCP uses this to reduce data rate before queues overflow.

---

# üü¶ So what is ‚ÄúType of Service‚Äù today?

Even though the IPv4 header still labels this byte as **Type of Service**, its meaning is:

> **Upper 6 bits = DSCP (QoS class)**
> **Lower 2 bits = ECN (congestion signaling)**

The old ToS meaning (precedence, delay, throughput, reliability) is no longer used.

---

# ‚úî Final Summary

### **Original (obsolete) ToS field:**

* **3 bits**: Precedence
* **1 bit**: Minimize delay
* **1 bit**: Maximize throughput
* **1 bit**: Maximize reliability
* **3 bits**: unused

### **Modern ToS field:**

* **6 bits**: DSCP (QoS classification)
* **2 bits**: ECN (congestion notification)








# ‚úÖ **Context**

When an Ethernet frame arrives (e.g., from a NIC):

* The NIC driver hands the frame to the kernel network stack.
* The frame has an **Ethernet header**, which contains a **EtherType** field (2 bytes):

```
0x0800 ‚Üí IPv4
0x86DD ‚Üí IPv6
0x0806 ‚Üí ARP
0x8847 ‚Üí MPLS
...
```

This EtherType value tells the kernel **which protocol handler should process the payload**.

---

# üü¶ **How Linux Registers IPv4 Packet Handler**

You saw this:

```c
static struct packet_type ip_packet_type __read_mostly = {
    .type = cpu_to_be16(ETH_P_IP),
    .func = ip_rcv,
};
```

Let‚Äôs decode it:

### ‚úî `.type = cpu_to_be16(ETH_P_IP)`

ETH_P_IP is defined as:

```c
#define ETH_P_IP 0x0800
```

`cpu_to_be16()` ensures the constant is stored in **big-endian**, because EtherType on the wire is big-endian.

So Linux is saying:

> ‚ÄúIf you see a frame whose EtherType == 0x0800 (IPv4), call ip_rcv().‚Äù

### ‚úî `.func = ip_rcv`

`ip_rcv()` is the **IPv4 receive handler** ‚Äî the entry point for the IPv4 Rx path.

---

# üü© **Registering the handler: dev_add_pack()**

In `inet_init()` (IPv4 initialization):

```c
dev_add_pack(&ip_packet_type);
```

This function registers `ip_packet_type` in the kernel‚Äôs **packet handler list**.

Now the network stack knows:

| EtherType | Handler      |
| --------- | ------------ |
| 0x0800    | **ip_rcv()** |
| 0x86DD    | ipv6_rcv()   |
| 0x0806    | arp_rcv()    |


---

# üüß **What happens when an IPv4 frame arrives?**

NIC driver ‚Üí `netif_rx()` ‚Üí kernel networking core

The kernel:

1. Reads the Ethernet header
2. Extracts the EtherType = e.g. **0x0800**
3. Searches registered protocol handlers in the `ptype_base` list
4. Finds the one with `.type = ETH_P_IP`
5. Calls:

```
ip_rcv(skb, dev, packet_type, orig_dev);
```

This begins the **IPv4 receive path**.

---

# üü¶ **What happens inside ip_rcv()?**

(You‚Äôll see this next in your reading)

`ip_rcv()`:

1. Validates the IPv4 header (checksum, version)
2. Checks packet length
3. Handles fragmentation (if any)
4. Sends it to LOCAL delivery or FORWARDING path:

* If destination IP == local machine ‚Üí goes to transport layer (TCP/UDP/ICMP)
* Otherwise ‚Üí may be forwarded (router mode)

---

# üü® **Why this matters**

Understanding the registration of:

```c
dev_add_pack(&ip_packet_type);
```

is crucial because **this is how Linux knows which function should process which packet**, based on protocol.

---

# üü© Summary

| Layer              | Data Type          | Kernel Mechanism                   |
| ------------------ | ------------------ | ---------------------------------- |
| Layer 2 (Ethernet) | EtherType = 0x0800 | Registered using `dev_add_pack()`  |
| Layer 3 (IPv4)     | IPv4 packet        | Handled by `ip_rcv()`              |
| Layer 4 (TCP/UDP)  | Transport headers  | Dispatched after `ip_rcv_finish()` |

---

If you want, I can walk you through **the full IPv4 receive path** step-by-step, including:

* `ip_rcv()`
* `ip_rcv_finish()`
* routing decision
* passing to TCP / UDP / ICMP


When forwarding, the kernel removes only the old L2 header, keeps and updates the L3 (IP) header, and then creates a NEW L2 header for the next hop.

So your confusion comes from thinking L2/L3 headers are only ‚Äúread.‚Äù
In reality:

L2 header is always stripped and rebuilt per hop.

L3 header stays (with some updates like TTL, checksum).







Between the ip_rcv() method and the ip_rcv_finish() method is the NF_INET_PRE_ROUTING
netfilter hook, invoked by calling the NF_HOOK macro

The netfilter subsystem
allows you to register callbacks in five points along the journey of a packet in the network stack. These points will be
mentioned by their names shortly. The reason for adding the netfilter hooks is to enable loading the netfilter kernel
modules at runtime.

the NF_HOOK_COND macro includes a Boolean parameter (the last
parameter), which must be true for the hook to be executed




if (iph->ihl < 5 || iph->version != 4)
goto inhdr_error;

if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))
goto inhdr_error;

return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
ip_rcv_finish);

When the registered netfilter hook method returns NF_DROP, it means that the packet should be dropped, and the
packet traversal does not continue. When the registered netfilter hook returns NF_STOLEN, it means that the packet
was taken over by the netfilter subsystem, and the packet traversal does not continue



‚úÖ What NF_STOLEN Really Means

When your hook function returns NF_STOLEN, you are telling Netfilter:

‚ÄúDo NOT continue packet processing.
I have taken responsibility for this packet.
I will free it, modify it, retransmit it, queue it, or otherwise dispose of it myself.‚Äù

Because you now own the packet, Netfilter will:

NOT pass it to remaining hooks

NOT reinject it

NOT free it

NOT forward, drop, or deliver it

You must eventually decide what to do with the packet.

‚ùó What happens if you return NF_STOLEN but do nothing?

You will create a memory leak, because Netfilter will assume ‚Äúthe handler is managing the packet now.‚Äù

This is why NF_STOLEN is used only in special situations.




If there is no dst attached to the SKB, a lookup in the routing subsystem is performed by the
ip_route_input_noref() method. If the lookup fails, the packet is dropped. Note that handling multicast packets is
different than handling unicast packets
Now a check is performed to see whether the IPv4 header includes options. Because the length of the IPv4 header
(ihl) is measured in multiples of 4 bytes, if it is greater than 5 this means that it includes options, so the ip_rcv_options()
method should be invoked to handle these options.



The IP options field of the IPv4 header is optional and is not often used for security reasons and because of processing
overhead. Which options might be helpful? Suppose, for example, that your packets are being dropped by a certain
firewall. You may be able to specify a different route with the Strict or Loose Source Routing options. Or if you want to
find out the packets‚Äô path to some destination addresses, you can use the Record Route option.







## **Two kinds of IP options**

### **1. Single-byte options**

These have **only the option type** byte:

* **End of Option List (EOL)**
* **No Operation (NOP)**

### **2. Multibyte options**

Format:

```
| Type | Length | Pointer | Option Data... |
```

* **Type** = what the option is
* **Length** = total size of this option
* **Pointer** = offset into the data (used by RR, Timestamp, etc.)
* **Option Data** = e.g., timestamps, IP addresses, route entries

---

# ‚úÖ **Copied Flag**

Inside the option type byte:

* If **copied flag = 1** ‚Üí option must be copied into **all fragments**
* If **copied flag = 0** ‚Üí option only appears in **the first fragment**

The kernel uses **IPOPT_COPIED(option)** to check this.

In fragmentation, the kernel:

* **keeps** options that must be copied
* **replaces** non-copied options with **NOP** in other fragments

---



In Linux:

* Only **IPOPT_TIMESTAMP** is a measurement option.
* Most others (like RR, SSRR, LSRR) are **control** options.

---

# ‚úÖ **Option Number (0‚Äì31)**

This identifies the specific option type.
Not all numbers are used; Linux implements only some of them.

---
+------------------------------------------------------+
|                    IP OPTIONS                        |
+------------------------------------------------------+
| Option 1 | Option 2 | Option 3 | ... | Option N |
+------------------------------------------------------+
Each option has one of these two formats:



Either this 
+----------------------+
| Option Type (8 bits) |
+----------------------+
Used only for:

0 ‚Üí End of Option List (EOL)

1 ‚Üí No Operation (NOP)

No length, no pointer, no data.


or 


+------------------------------------------------------------------------+
|  Option Type (8 bits)  |  Length (8 bits)  | Pointer (8 bits)         |
+------------------------------------------------------------------------+
|                     Option Data (variable length)                      |
+------------------------------------------------------------------------+




inside option type byte


      +--------+----------------------------------------------+
      |Copied (1 bit)  |   Class (2 bits)  |  Number (5 bits) |
      +--------+----------------------------------------------+

# ‚úÖ **Option Classes**

The option type byte also contains a **2-bit class field**:

| Bits | Meaning               |
| ---- | --------------------- |
| 00   | Control (most common) |
| 01   | Reserved1             |
| 10   | Debug/measurement     |
| 11   | Reserved2             |

only timestamp is used for measurement





basically 

                           MULTI-BYTE OPTION
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        Option Type    8bit                 ‚îÇ
‚îÇ                                                            ‚îÇ
‚îÇ+----------+--------------+---------------------------------+
‚îÇ| Copied=0 | Class=00     | Number=xxxxx                    |
‚îÇ+----------+--------------+---------------------------------+
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Length (total bytes)   ‚îÇ  1 byte
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Pointer / Offset       ‚îÇ  1 byte
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Option Data (varies)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


3 types of timestamp flags 


tsandaddr
ping -T tsandaddr 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(124) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.019 ms
TS: 	127.0.0.1	40871938 absolute
	127.0.0.1	0
	127.0.0.1	0
	127.0.0.1	0

tsprespec
 ‚úò ÓÇ∞ asit ÓÇ∞ ÓÇ† main ÓÇ∞ ping -T tsprespec 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(124) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.020 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.019 ms


tsonly
ping -T tsonly 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(124) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.023 ms
TS: 	40812077 absolute
	0
	0
	0




# ‚úÖ **IPv4 Timestamp Option (IPOPT_TIMESTAMP) ‚Äî Key Points**

* Defined in **RFC 781**.
* Stores **timestamps** (32-bit, milliseconds since midnight UTC).
* Can store:

  * Only timestamps, or
  * IP address + timestamp pairs.
* Records timestamps of routers along the path.
* **Maximum total option length:** **40 bytes**.
* **Not copied** into fragments ‚Üí appears **only in the first fragment**.
* Structure begins with:

  * **Type (1 byte)**
  * **Length (1 byte)**
  * **Pointer (1 byte)**
* **Fourth byte:**

  * Upper 4 bits = **overflow counter** (incremented when no space is left to add another entry).
* If overflow counter > 15 ‚Üí send **ICMP Parameter Problem** back to sender.




‚úÖ Strict Source Route (SSRR)

Packet must pass through each router exactly in the specified order.

No other routers are allowed between the listed hops.

If the next hop is not directly reachable, the packet is dropped.

Very strict path control.

Think: ‚ÄúFollow this exact path, step by step.‚Äù

‚úÖ Loose Source Route (LSRR)

Packet must pass through the listed routers, but

It may use any routers in between the listed ones.

Next hop does not need to be directly reachable.

More flexible path control.
Even though LSRR allows any routers in between, the packet must still visit the listed routers in the exact sequence given.







The command-line utility ping ‚ÄìR uses the Record Route IP Option. Note that
the IPv4 header is only large enough for nine such routes (or even less, if more options are used). When the header is
full and there is no room to insert an additional address, the datagram is forwarded without inserting the address to
the IP options.
Though ping ‚ÄìR uses the Record Route IP Option, in many cases, if you will try it, you will not get the expected
result of all the network nodes along the way, because for security reasons many network nodes ignore this IP option.
The manpage of ping mentions this explicitly.







# ‚úÖ **ip_options_compile() ‚Äî Simple Explanation**

### **What it does**

`ip_options_compile()` reads the **IP options** from the IPv4 header and converts them into a clean, easy-to-use structure called **ip_options**.


* `ip_options_compile()` converts raw IP options into a structured form.
* Called for incoming packets and for options set by userspace.
* On error in Rx ‚Üí sends ICMP Parameter Problem.
* Parsed options are stored inside `skb->cb` in `inet_skb_parm.opt`.
* Kernel modules later use this `ip_options` structure instead of parsing raw IP headers again.









imp * Parsed options are stored inside `skb->cb` in `inet_skb_parm.opt`.





# üåü **FINAL SIMPLE SUMMARY**

**ip_options_compile() does this:**

1. Finds where the IP options are.
2. Walks through each option byte by byte.
3. Handles END, NOP, RR, Timestamp, SSRR, LSRR.
4. Validates everything; sends ICMP error if malformed.
5. Fills a nice struct (`ip_options`) inside SKB's control buffer.
6. For RR and Timestamp: inserts address/timestamp into option.
7. For SSRR/LSRR: finds next hop and prepares routing.
8. Marks header changed and updates state.

This allows the rest of the kernel to work with **parsed, validated, easy-to-access** IP options instead of raw bytes.






The ip_options_build() method can be thought of as the reverse of the ip_options_compile() method you saw
earlier in this chapter. It takes an ip_options object as an argument and writes its content to the IPv4 header.










# ‚úÖ **Background: What is the ‚Äúcopied flag‚Äù in IP options?**

Every IP option starts with **1 byte = option type**, where:

```
bit 7   = copied flag  
bits 6-5 = option class  
bits 4-0 = option number
```

### ‚úî **Copied flag = 1**

‚Üí This option **must be copied into ALL fragments** when the packet is fragmented.

### ‚úî **Copied flag = 0**

‚Üí This option is copied **only into the FIRST fragment**.

---

# ‚úÖ **Why do we need this?**

Because some options are required for every fragment (e.g., security),
while others only make sense in the first fragment (e.g., RR, TS).

---

# ‚úÖ **Where fragmentation is handled**

The main fragmentation logic happens in:

```
ip_fragment()
```

Before creating fragments, it calls:

```
ip_options_fragment()
```

This function decides which options will appear in the first fragment and which ones need to be copied into all fragments.

---

# üöÄ **What does ip_options_fragment() do?**

### It runs only **for the first fragment**.

Inside `ip_options_fragment()`:

1. It looks at the **compiled ip_options** object (already parsed earlier).
2. For each option, it checks:

   * If `copied` flag = 1 ‚Üí keep this option in **all fragments**
   * If `copied` flag = 0 ‚Üí **present only in the first fragment**
3. When an option should NOT be copied into later fragments, it is replaced by:

   ```
   IPOPT_NOOP (No-Operation)
   ```

   to maintain 32-bit alignment.



























