IPV4

id: Identification of the IPv4 header. The id field is important for fragmentation: when
fragmenting an SKB, the id value of all the fragments of that SKB should be the same.
Reassembling fragmented packets is done according to the id of the fragments.


frag_off: The fragment offset, a 16-bit field. The lower 13 bits are the offset of the fragment.
In the first fragment, the offset is 0. The offset is measured in units of 8 bytes. The higher 3 bits
are the flags:
â€¢001 is MF (More Fragments). It is set for all fragments, except the last one.
â€¢010 is DF (Donâ€™t Fragment).
â€¢100 is CE (Congestion).
See the IP_MF, IP_DF, and IP_CE flags declaration in include/net/ip.h.

ttl: Time To Live: this is a hop counter. Each forwarding node decreases the ttl by 1. When
it reaches 0, the packet is discarded, and a time exceeded ICMPv4 message is sent back; this
avoids packets from being forwarded endlessly, for this reason or another.


The **Type of Service (ToS)** field in the IPv4 header specifies **how the packet should be handled** by routersâ€”its priority, delay requirements, throughput needs, reliability, etc.

Originally, ToS was an 8-bit field, but it has evolved over time.
Letâ€™s go through both the **old interpretation** and the **modern one (DSCP/ECN)**.

---

# âœ… **Original IPv4 Type of Service (RFC 791)**

This is the classical structure:

```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   PRECEDENCE   |D|T|R|0|0|0|
+---+---+---+---+---+---+---+---+
```

### 1) **3-bit Precedence**

Indicates priority of the datagram.

| Value | Meaning              |
| ----- | -------------------- |
| 000   | Routine              |
| 001   | Priority             |
| 010   | Immediate            |
| 011   | Flash                |
| 100   | Flash Override       |
| 101   | CRITIC/ECP           |
| 110   | Internetwork Control |
| 111   | Network Control      |

Higher value = higher priority.

---

### 2) **D, T, R flags (1 bit each)**

| Bit | Meaning     | What it asks routers to do |
| --- | ----------- | -------------------------- |
| D   | Delay       | Prefer low delay           |
| T   | Throughput  | Prefer high throughput     |
| R   | Reliability | Prefer high reliability    |

Only one of these was supposed to be set at once.

---

### 3) Last 3 bits: Always zero (unused)

---

# âŒ This original ToS is **obsolete**

Routers do NOT use these bits anymore.
Instead, they use the **DSCP/ECN** interpretation defined in RFC 2474 and RFC 3168.

---

# ðŸŸ© Modern meaning of the Type of Service byte

The 8-bit ToS field was **redefined**:

```
+-----------------------+------------+
|        DSCP (6 bits)  |  ECN (2 bits) |
+-----------------------+------------+
```

---

# âœ… **1. DSCP (Differentiated Services Code Point) â€“ 6 bits**

Used for **QoS (Quality of Service)** classification.
Routers use DSCP to decide queueing, scheduling, and priority.

Example DSCP values:

| DSCP (bits) | Name                      | Purpose                    |
| ----------- | ------------------------- | -------------------------- |
| 000000      | BE (Best Effort)          | Normal traffic             |
| 101110      | EF (Expedited Forwarding) | Low loss, low delay (VoIP) |
| 001010      | AF11                      | Assured Forwarding         |
| 010010      | AF21                      | Assured Forwarding         |
| 011010      | AF31                      | Assured Forwarding         |

---

# âœ… **2. ECN (Explicit Congestion Notification) â€“ 2 bits**

Used for **active congestion control** without dropping packets.

| ECN bits | Meaning                |
| -------- | ---------------------- |
| 00       | Not ECN-capable        |
| 01       | ECN-capable transport  |
| 10       | ECN-capable transport  |
| 11       | Congestion encountered |

TCP uses this to reduce data rate before queues overflow.

---

# ðŸŸ¦ So what is â€œType of Serviceâ€ today?

Even though the IPv4 header still labels this byte as **Type of Service**, its meaning is:

> **Upper 6 bits = DSCP (QoS class)**
> **Lower 2 bits = ECN (congestion signaling)**

The old ToS meaning (precedence, delay, throughput, reliability) is no longer used.

---

# âœ” Final Summary

### **Original (obsolete) ToS field:**

* **3 bits**: Precedence
* **1 bit**: Minimize delay
* **1 bit**: Maximize throughput
* **1 bit**: Maximize reliability
* **3 bits**: unused

### **Modern ToS field:**

* **6 bits**: DSCP (QoS classification)
* **2 bits**: ECN (congestion notification)








# âœ… **Context**

When an Ethernet frame arrives (e.g., from a NIC):

* The NIC driver hands the frame to the kernel network stack.
* The frame has an **Ethernet header**, which contains a **EtherType** field (2 bytes):

```
0x0800 â†’ IPv4
0x86DD â†’ IPv6
0x0806 â†’ ARP
0x8847 â†’ MPLS
...
```

This EtherType value tells the kernel **which protocol handler should process the payload**.

---

# ðŸŸ¦ **How Linux Registers IPv4 Packet Handler**

You saw this:

```c
static struct packet_type ip_packet_type __read_mostly = {
    .type = cpu_to_be16(ETH_P_IP),
    .func = ip_rcv,
};
```

Letâ€™s decode it:

### âœ” `.type = cpu_to_be16(ETH_P_IP)`

ETH_P_IP is defined as:

```c
#define ETH_P_IP 0x0800
```

`cpu_to_be16()` ensures the constant is stored in **big-endian**, because EtherType on the wire is big-endian.

So Linux is saying:

> â€œIf you see a frame whose EtherType == 0x0800 (IPv4), call ip_rcv().â€

### âœ” `.func = ip_rcv`

`ip_rcv()` is the **IPv4 receive handler** â€” the entry point for the IPv4 Rx path.

---

# ðŸŸ© **Registering the handler: dev_add_pack()**

In `inet_init()` (IPv4 initialization):

```c
dev_add_pack(&ip_packet_type);
```

This function registers `ip_packet_type` in the kernelâ€™s **packet handler list**.

Now the network stack knows:

| EtherType | Handler      |
| --------- | ------------ |
| 0x0800    | **ip_rcv()** |
| 0x86DD    | ipv6_rcv()   |
| 0x0806    | arp_rcv()    |


---

# ðŸŸ§ **What happens when an IPv4 frame arrives?**

NIC driver â†’ `netif_rx()` â†’ kernel networking core

The kernel:

1. Reads the Ethernet header
2. Extracts the EtherType = e.g. **0x0800**
3. Searches registered protocol handlers in the `ptype_base` list
4. Finds the one with `.type = ETH_P_IP`
5. Calls:

```
ip_rcv(skb, dev, packet_type, orig_dev);
```

This begins the **IPv4 receive path**.

---

# ðŸŸ¦ **What happens inside ip_rcv()?**

(Youâ€™ll see this next in your reading)

`ip_rcv()`:

1. Validates the IPv4 header (checksum, version)
2. Checks packet length
3. Handles fragmentation (if any)
4. Sends it to LOCAL delivery or FORWARDING path:

* If destination IP == local machine â†’ goes to transport layer (TCP/UDP/ICMP)
* Otherwise â†’ may be forwarded (router mode)

---

# ðŸŸ¨ **Why this matters**

Understanding the registration of:

```c
dev_add_pack(&ip_packet_type);
```

is crucial because **this is how Linux knows which function should process which packet**, based on protocol.

---

# ðŸŸ© Summary

| Layer              | Data Type          | Kernel Mechanism                   |
| ------------------ | ------------------ | ---------------------------------- |
| Layer 2 (Ethernet) | EtherType = 0x0800 | Registered using `dev_add_pack()`  |
| Layer 3 (IPv4)     | IPv4 packet        | Handled by `ip_rcv()`              |
| Layer 4 (TCP/UDP)  | Transport headers  | Dispatched after `ip_rcv_finish()` |

---

If you want, I can walk you through **the full IPv4 receive path** step-by-step, including:

* `ip_rcv()`
* `ip_rcv_finish()`
* routing decision
* passing to TCP / UDP / ICMP


When forwarding, the kernel removes only the old L2 header, keeps and updates the L3 (IP) header, and then creates a NEW L2 header for the next hop.

So your confusion comes from thinking L2/L3 headers are only â€œread.â€
In reality:

L2 header is always stripped and rebuilt per hop.

L3 header stays (with some updates like TTL, checksum).







Between the ip_rcv() method and the ip_rcv_finish() method is the NF_INET_PRE_ROUTING
netfilter hook, invoked by calling the NF_HOOK macro

The netfilter subsystem
allows you to register callbacks in five points along the journey of a packet in the network stack. These points will be
mentioned by their names shortly. The reason for adding the netfilter hooks is to enable loading the netfilter kernel
modules at runtime.

the NF_HOOK_COND macro includes a Boolean parameter (the last
parameter), which must be true for the hook to be executed




if (iph->ihl < 5 || iph->version != 4)
goto inhdr_error;

if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))
goto inhdr_error;

return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
ip_rcv_finish);

When the registered netfilter hook method returns NF_DROP, it means that the packet should be dropped, and the
packet traversal does not continue. When the registered netfilter hook returns NF_STOLEN, it means that the packet
was taken over by the netfilter subsystem, and the packet traversal does not continue



âœ… What NF_STOLEN Really Means

When your hook function returns NF_STOLEN, you are telling Netfilter:

â€œDo NOT continue packet processing.
I have taken responsibility for this packet.
I will free it, modify it, retransmit it, queue it, or otherwise dispose of it myself.â€

Because you now own the packet, Netfilter will:

NOT pass it to remaining hooks

NOT reinject it

NOT free it

NOT forward, drop, or deliver it

You must eventually decide what to do with the packet.

â— What happens if you return NF_STOLEN but do nothing?

You will create a memory leak, because Netfilter will assume â€œthe handler is managing the packet now.â€

This is why NF_STOLEN is used only in special situations.




If there is no dst attached to the SKB, a lookup in the routing subsystem is performed by the
ip_route_input_noref() method. If the lookup fails, the packet is dropped. Note that handling multicast packets is
different than handling unicast packets
Now a check is performed to see whether the IPv4 header includes options. Because the length of the IPv4 header
(ihl) is measured in multiples of 4 bytes, if it is greater than 5 this means that it includes options, so the ip_rcv_options()
method should be invoked to handle these options.



The IP options field of the IPv4 header is optional and is not often used for security reasons and because of processing
overhead. Which options might be helpful? Suppose, for example, that your packets are being dropped by a certain
firewall. You may be able to specify a different route with the Strict or Loose Source Routing options. Or if you want to
find out the packetsâ€™ path to some destination addresses, you can use the Record Route option.







## **Two kinds of IP options**

### **1. Single-byte options**

These have **only the option type** byte:

* **End of Option List (EOL)**
* **No Operation (NOP)**

### **2. Multibyte options**

Format:

```
| Type | Length | Pointer | Option Data... |
```

* **Type** = what the option is
* **Length** = total size of this option
* **Pointer** = offset into the data (used by RR, Timestamp, etc.)
* **Option Data** = e.g., timestamps, IP addresses, route entries

---

# âœ… **Copied Flag**

Inside the option type byte:

* If **copied flag = 1** â†’ option must be copied into **all fragments**
* If **copied flag = 0** â†’ option only appears in **the first fragment**

The kernel uses **IPOPT_COPIED(option)** to check this.

In fragmentation, the kernel:

* **keeps** options that must be copied
* **replaces** non-copied options with **NOP** in other fragments

---



In Linux:

* Only **IPOPT_TIMESTAMP** is a measurement option.
* Most others (like RR, SSRR, LSRR) are **control** options.

---

# âœ… **Option Number (0â€“31)**

This identifies the specific option type.
Not all numbers are used; Linux implements only some of them.

---
+------------------------------------------------------+
|                    IP OPTIONS                        |
+------------------------------------------------------+
| Option 1 | Option 2 | Option 3 | ... | Option N |
+------------------------------------------------------+
Each option has one of these two formats:



Either this 
+----------------------+
| Option Type (8 bits) |
+----------------------+
Used only for:

0 â†’ End of Option List (EOL)

1 â†’ No Operation (NOP)

No length, no pointer, no data.


or 


+------------------------------------------------------------------------+
|  Option Type (8 bits)  |  Length (8 bits)  | Pointer (8 bits)         |
+------------------------------------------------------------------------+
|                     Option Data (variable length)                      |
+------------------------------------------------------------------------+




inside option type byte


      +--------+----------------------------------------------+
      |Copied (1 bit)  |   Class (2 bits)  |  Number (5 bits) |
      +--------+----------------------------------------------+

# âœ… **Option Classes**

The option type byte also contains a **2-bit class field**:

| Bits | Meaning               |
| ---- | --------------------- |
| 00   | Control (most common) |
| 01   | Reserved1             |
| 10   | Debug/measurement     |
| 11   | Reserved2             |

only timestamp is used for measurement





basically 

                           MULTI-BYTE OPTION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Option Type    8bit                 â”‚
â”‚                                                            â”‚
â”‚+----------+--------------+---------------------------------+
â”‚| Copied=0 | Class=00     | Number=xxxxx                    |
â”‚+----------+--------------+---------------------------------+
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Length (total bytes)   â”‚  1 byte
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pointer / Offset       â”‚  1 byte
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Option Data (varies)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


3 types of timestamp flags 


tsandaddr
ping -T tsandaddr 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(124) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.019 ms
TS: 	127.0.0.1	40871938 absolute
	127.0.0.1	0
	127.0.0.1	0
	127.0.0.1	0

tsprespec
 âœ˜ î‚° asit î‚° î‚  main î‚° ping -T tsprespec 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(124) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.020 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.019 ms


tsonly
ping -T tsonly 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(124) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.023 ms
TS: 	40812077 absolute
	0
	0
	0




# âœ… **IPv4 Timestamp Option (IPOPT_TIMESTAMP) â€” Key Points**

* Defined in **RFC 781**.
* Stores **timestamps** (32-bit, milliseconds since midnight UTC).
* Can store:

  * Only timestamps, or
  * IP address + timestamp pairs.
* Records timestamps of routers along the path.
* **Maximum total option length:** **40 bytes**.
* **Not copied** into fragments â†’ appears **only in the first fragment**.
* Structure begins with:

  * **Type (1 byte)**
  * **Length (1 byte)**
  * **Pointer (1 byte)**
* **Fourth byte:**

  * Upper 4 bits = **overflow counter** (incremented when no space is left to add another entry).
* If overflow counter > 15 â†’ send **ICMP Parameter Problem** back to sender.




âœ… Strict Source Route (SSRR)

Packet must pass through each router exactly in the specified order.

No other routers are allowed between the listed hops.

If the next hop is not directly reachable, the packet is dropped.

Very strict path control.

Think: â€œFollow this exact path, step by step.â€

âœ… Loose Source Route (LSRR)

Packet must pass through the listed routers, but

It may use any routers in between the listed ones.

Next hop does not need to be directly reachable.

More flexible path control.
Even though LSRR allows any routers in between, the packet must still visit the listed routers in the exact sequence given.







The command-line utility ping â€“R uses the Record Route IP Option. Note that
the IPv4 header is only large enough for nine such routes (or even less, if more options are used). When the header is
full and there is no room to insert an additional address, the datagram is forwarded without inserting the address to
the IP options.
Though ping â€“R uses the Record Route IP Option, in many cases, if you will try it, you will not get the expected
result of all the network nodes along the way, because for security reasons many network nodes ignore this IP option.
The manpage of ping mentions this explicitly.







# âœ… **ip_options_compile() â€” Simple Explanation**

### **What it does**

`ip_options_compile()` reads the **IP options** from the IPv4 header and converts them into a clean, easy-to-use structure called **ip_options**.


* `ip_options_compile()` converts raw IP options into a structured form.
* Called for incoming packets and for options set by userspace.
* On error in Rx â†’ sends ICMP Parameter Problem.
* Parsed options are stored inside `skb->cb` in `inet_skb_parm.opt`.
* Kernel modules later use this `ip_options` structure instead of parsing raw IP headers again.









imp * Parsed options are stored inside `skb->cb` in `inet_skb_parm.opt`.





# ðŸŒŸ **FINAL SIMPLE SUMMARY**

**ip_options_compile() does this:**

1. Finds where the IP options are.
2. Walks through each option byte by byte.
3. Handles END, NOP, RR, Timestamp, SSRR, LSRR.
4. Validates everything; sends ICMP error if malformed.
5. Fills a nice struct (`ip_options`) inside SKB's control buffer.
6. For RR and Timestamp: inserts address/timestamp into option.
7. For SSRR/LSRR: finds next hop and prepares routing.
8. Marks header changed and updates state.

This allows the rest of the kernel to work with **parsed, validated, easy-to-access** IP options instead of raw bytes.






The ip_options_build() method can be thought of as the reverse of the ip_options_compile() method you saw
earlier in this chapter. It takes an ip_options object as an argument and writes its content to the IPv4 header.










# âœ… **Background: What is the â€œcopied flagâ€ in IP options?**

Every IP option starts with **1 byte = option type**, where:

```
bit 7   = copied flag  
bits 6-5 = option class  
bits 4-0 = option number
```

### âœ” **Copied flag = 1**

â†’ This option **must be copied into ALL fragments** when the packet is fragmented.

### âœ” **Copied flag = 0**

â†’ This option is copied **only into the FIRST fragment**.

---

# âœ… **Why do we need this?**

Because some options are required for every fragment (e.g., security),
while others only make sense in the first fragment (e.g., RR, TS).

---

# âœ… **Where fragmentation is handled**

The main fragmentation logic happens in:

```
ip_fragment()
```

Before creating fragments, it calls:

```
ip_options_fragment()
```

This function decides which options will appear in the first fragment and which ones need to be copied into all fragments.

---

# ðŸš€ **What does ip_options_fragment() do?**

### It runs only **for the first fragment**.

Inside `ip_options_fragment()`:

1. It looks at the **compiled ip_options** object (already parsed earlier).
2. For each option, it checks:

   * If `copied` flag = 1 â†’ keep this option in **all fragments**
   * If `copied` flag = 0 â†’ **present only in the first fragment**
3. When an option should NOT be copied into later fragments, it is replaced by:

   ```
   IPOPT_NOOP (No-Operation)
   ```

   to maintain 32-bit alignment.



















A packet begins in the **transport layer** (TCP/UDP/ICMP). The kernel wraps the transport payload into an `sk_buff` (socket buffer â€” `skb`) and then runs the skb through several layers: local output hooks (for firewall/iptables), routing/decision making (which device and next hop), IP processing (fragmentation, headers, checksums, options), post-routing hooks, and finally the network device transmit queue (`dev_queue_xmit`) which hands it to the network driver.

Keep this flow in mind: **transport â†’ ip_local_out â†’ routing/output â†’ post-routing â†’ device queue â†’ driver**.

---

# Step-by-step with purpose and details

### Transport layer: TCP vs UDP/ICMP entry points

* **TCP**: commonly uses `ip_queue_xmit()` (TCP constructs packets with segmentation, options, and then queues them to IP).

  * **Why separate?** TCP requires segmentation offload, retransmit handling, and sometimes special skb queuing before handing to IP.
* **UDP/ICMP**: often use helpers like `ip_append_data()` â†’ `ip_push_pending_frames()` â†’ `ip_send_skb()` to build and send one or few datagrams quickly.

  * **Why separate?** UDP is connectionless and typically sends small independent datagrams; helper functions accumulate or push frames efficiently.

(So both sides eventually produce an `skb` and call a common IP entry function.)

---

### `ip_send_skb()` / `ip_queue_xmit()` â†’ `ip_local_out()`

* **Purpose:** These are the last transport-side helpers that hand the prepared `skb` to the IP stack. They normalize/prepare the skb and call `ip_local_out()`.
* **Need:** unify all packets coming from local processes into a single IP output path where routing, hooks, and IP-level processing are done.

---

### `ip_local_out(struct net *net, struct sk_buff *skb)`

* **What it does:** Entry point for packets originating locally. Does initial sanity checks (e.g., `skb` length, IP header present or to be created), sets up metadata, and calls netfilter hook `NF_INET_LOCAL_OUT`.
* **Why needed:** A single, canonical place to start IP-level processing for locally generated traffic. Ensures every outgoing packet from local host can be inspected/modified/filtered by the rest of the stack.

---

### `NF_INET_LOCAL_OUT` (netfilter hook)

* **What it does:** Invokes registered netfilter/iptables hooks for **LOCAL_OUT**. Firewall modules, NAT, connection tracking can accept, modify, drop, or mangle the skb.
* **Why needed:** User wants iptables/NAT and other LSM-like features applied to packets leaving the host. Important for firewalling, nat (SNAT), conntrack for locally generated connections.
* **Effect on flow:** Hook can:

  * allow packet â†’ continue,
  * modify (e.g., SNAT changes source address) â†’ routing decisions may change,
  * drop packet â†’ stop,
  * queue for userspace â†’ wait for verdict (e.g., NFQUEUE).

---

### `dst_output()` (destination output)

* **What it does:** After netfilter, the stack must decide *where* to send the packet. `dst_output()` looks up the `dst` (destination cache / routing entry) for the skb. It chooses route, device, next hop, and output function.
* **Why needed:** Routing and path selection are separate concerns. `dst` holds cached route info including output device, gateway, MTU, and functions for output. This avoids recomputing routing for every packet.
* **Details:**

  * if no route exists, routing lookup happens here (or earlier), and `-ENETUNREACH` returned.
  * `dst` holds pointers to a `neighbour` (ARP) for next-hop MAC resolution when needed.

---

### `ip_output()` and `ip_mc_output()`

* **`ip_output()`**:

  * **What:** The normal unicast IPv4 output processing path. It prepares the IP header, handles fragmentation if required (or defers via GSO/TSO), calculates checksums (unless offloaded), processes IP options, TTL, and possibly raw socket hooks.
  * **Why:** IP-level operations (header fields, fragmentation, TTL, checksum) must be applied uniformly.
  * **Key tasks inside:**

    * ensure `skb->protocol` is ETH_P_IP
    * set TTL, TOS, options
    * perform fragmentation if packet > MTU (unless offload or DF set)
    * call device-specific output via `dst_output()` or a function pointer in `dst`
* **`ip_mc_output()`**:

  * **What:** Special path for **multicast** packets. Multicast can be sent out on multiple interfaces and may need group-specific handling (loopback, TTL scoping, multicast routing).
  * **Why separate?** Multicast semantics (multiple output interfaces, loopback to local sockets, TTL scoping, IGMP interactions) differ from simple unicast.

---

### `NF_INET_POST_ROUTING` (postrouting netfilter hook)

* **What it does:** Invokes netfilter hooks registered for **POSTROUTING**. This is the last chance to inspect/modify the packet before it hits the wire.
* **Why needed:** NAT (SNAT) often applied here; egress filtering can be done; final packet mangling/marking. POSTROUTING sees the actual packet that will leave the host, after routing decision.
* **Important:** If NAT changes IP addresses, checksums must be updated. Also changes can affect routing only if performed earlier; POSTROUTING is last step.

---

### `ip_finish_output()` (or similar)

* **What it does:** Final IP preparations before handing to device layer: update headers, final checksum computations (if not offloaded), update statistics, maybe set queue mapping (traffic control / qdisc), set skb->dev and skb->protocol for the ethernet layer.
* **Why:** Make sure the skb is fully ready and consistent for the device driver and lower layers.

---

### `dev_queue_xmit()` (device transmit queue)

* **What it does:** The interface into the networking device layer (netdevice). Places skb on the correct transmit queue (`qdisc`), runs queuing discipline (qdisc) and traffic control, calls the device driver `ndo_start_xmit()` (or helper) to actually transmit the packet.
* **Why needed:** Handles per-device queuing, shaping, and interacts with NIC features (TX rings, offload). It is where kernel maps traffic to hardware queues, handles congestion control at device level, and enqueues packets if necessary.
* **Notes:**

  * Might return error if device down.
  * May trigger `netdev_start_xmit` which hands hardware descriptor(s) the skb.
  * Supports features: XPS, GRO/TSO/GSO offload, and mapping skb to netdev queues.

---

### Network driver (hardware)

* **What happens here:** Driver puts packet into hardware transmit descriptors, notifies NIC (doorbell), NIC transmits on wire. Completion interrupts or poll handlers later free descriptors and skbs.
* **Why separate:** Hardware specifics (DMA, ring buffers, NIC offloads) are implemented in driver. Kernel provides generic interface (`dev_queue_xmit`) so different HW can plug in.

---

# Important cross-cutting concerns & why they exist

### skb (socket buffer) lifetime and metadata

* `skb` contains the payload and metadata (headers, destination route `dst`, socket pointers, skb->dev, skb->mark).
* The stack modifies skb in place (push/pop headers) and may clone or linearize it when needed.

### Routing caches (dst)

* Frequent optimization: route lookup is expensive. `dst` caching avoids repeated route computation and contains MTU and output function pointer.

### Fragmentation and PMTU

* If packet size > path MTU and DF (Don't Fragment) not set, kernel fragments the packet (`ip_fragment`). If DF set, returns error (ICMP need fragmentation).
* Modern stacks use GSO/TSO to defer fragmentation to NIC when supported.

### Checksums and offloads

* Kernel computes checksums unless NIC supports checksum offload. Offloads reduce CPU but require driver/NIC support.

### Netfilter ordering: LOCAL_OUT vs POSTROUTING

* LOCAL_OUT: first chance to see/alter locally generated packets (useful for local NAT, conntrack creation).
* POSTROUTING: last chance before leaving host (useful for SNAT and final adjustments).
* NAT commonly performs translation so that the outgoing packet has the right source IP (POSTROUTING mostly) â€” but conntrack hooks need LOCAL_OUT too.

### Multicast specialness

* Multicast packets can be duplicated and sent on multiple interfaces. They also may loop back to local sockets depending on settings. Thatâ€™s why `ip_mc_output()` exists.

### QoS / qdisc / traffic control

* `dev_queue_xmit()` interacts with the qdisc. Packet may be queued, shaped, or dropped due to congestion policies. This is where traffic control, queuing disciplines and fairness are enforced.

---

# Example simple flow (one unicast UDP packet)

1. Application `sendto()` â†’ socket layer builds `skb` with UDP header.
2. UDP helper calls `ip_send_skb()` â†’ `ip_local_out()`.
3. `ip_local_out()` runs `NF_INET_LOCAL_OUT` (iptables may SNAT or drop).
4. `dst_output()` / routing lookup picks the output device and next-hop.
5. `ip_output()` fills IP header: sets TTL, computes checksum, handles fragmentation if needed.
6. `NF_INET_POST_ROUTING` runs (final NAT, marking).
7. `ip_finish_output()` makes final changes and sets `skb->dev`.
8. `dev_queue_xmit()` enqueues and calls netdev start_xmit.
9. Network driver sends bytes on wire.

---

# Quick notes for practical debugging / reading code

* If packets don't leave: check iptables (LOCAL_OUT/POSTROUTING), routing table, `ip route get` may show the path, check device state.
* If NAT modifies IP: POSTROUTING is where SNAT usually happens.
* If small differences between TCP/UDP paths matter (e.g., segmentation), look at TCP `ip_queue_xmit()` and UDP `ip_send_skb()` implementations.
* For multicast: look at `ip_mc_output()` and IGMP handling.












When the ip_fragment() method is invoked
from ip_finish_output(), the output callback is the ip_finish_output2() method. There are two paths in the
ip_fragment() method: the fast path and the slow path. The fast path is for packets where the frag_list of the SKB is
not NULL, and the slow path is for packets that do not meet this condition.












Defragmentation is the process of reassembling all the fragments of a packet, which all have the same id in the IPv4
header, into one buffer. The main method that handles defragmentation in the Rx path is ip_defrag()






The ip_is_fragment() method returns true in either of two cases (or both):
â€¢The IP_MF flag is set.
â€¢The fragment offset is not 0



Thus it will return true on all fragments:
â€¢On the first fragment, where frag_off is 0 but the IP_MF flag is set.
â€¢On the last fragment, where frag_off is not 0 but the IP_MF flag is not set.
â€¢On all other fragments, where frag_off is not 0 and the IP_MF flag is set.







ip_defrag() Method - Cheat Sheet

Memory Availability Check:

Function: ip_evictor()

Purpose: Ensures enough memory is available for reassembling fragmented packets. If not, older fragments are evicted.

Find/Create Fragment Queue:

Function: ip_find()

Purpose: Searches for an existing ipq (fragment queue). If not found, creates a new ipq object to store fragments.

Add Fragment to Queue:

Function: ip_frag_queue()

Purpose: Adds each fragment to the fragment queue (ipq->q.fragments).

Key: Fragments are added in order of fragment offset (ensures correct reassembly).

Reassemble Fragments:

Function: ip_frag_reasm()

Purpose: Combines all fragments into a single, complete packet.

Checks:

Packet size > 65535 bytes â†’ Fail.

Memory allocation failure (e.g., skb_clone()) â†’ ENOMEM and failure.

On success: Clones the reassembled packet with skb_clone().

Timer Management:

Function: ip_expire()

Purpose: Ensures that the packet reassembly process completes within a timeout interval (default: 30 seconds).

If timeout: Sends ICMP "Time Exceeded" message.

Error Handling:

Reassembly Failures:

Too large (> 65535 bytes) â†’ Increment IPSTATS_MIB_REASMFAILS.

Memory Failure (e.g., skb_clone()) â†’ Increment IPSTATS_MIB_REASMFAILS and return ENOMEM.

Expire and Cleanup:

Function: ipq_kill()

Purpose: Cleans up and destroys the ipq (fragment queue) and stops the associated timer.














### **Key Operations in `ip_forward()`**:

1. **LRO (Large Receive Offload) Packets Check**:

   * **LRO** merges multiple small packets into a larger packet to optimize performance.
   * However, **LRO packets cannot be forwarded** because they might be larger than the MTU (Maximum Transmission Unit) of the outgoing interface.
   * If the packet was created using **LRO**, it is **dropped** because forwarding it could cause issues (e.g., larger than the MTU).
   * The check `skb_warn_if_lro(skb)` ensures that if LRO is detected, the packet is dropped using `goto drop;`.

2. **Router Alert Option**:

   * If the packet has the **router alert option**, it triggers the **`ip_call_ra_chain()`** method to deliver the packet to all **raw sockets**.
   * **Raw sockets** don't have ports like TCP/UDP sockets, so the packet is sent to **all raw sockets** in the system.

3. **Packet Type Check**:

   * The packet's type is checked with `skb->pkt_type`. If the packet is **not a host packet** (i.e., it's not destined for this router), it's dropped using `goto drop;`.

4. **Time To Live (TTL) Check**:

   * The **TTL field** of the IP header is checked. The TTL indicates how many hops (routers) the packet can make before it is discarded.
   * **If TTL <= 1**, the packet is discarded because it's too old (looped or sent on an invalid path). An **ICMP "Time Exceeded" message** is sent back to the sender.

5. **Strict Routing Check**:

   * If **strict routing** is enabled and the routing entry requires a **gateway**, it sends an **ICMP Destination Unreachable message** indicating that strict routing failed.

6. **MTU Check (Maximum Transmission Unit)**:

   * The packet is checked to see if it exceeds the **MTU** of the outgoing network interface. If it does, the packet can't be forwarded unless it's fragmented.
   * If the **Don't Fragment (DF)** flag is set in the IP header, and the packet is too large to be forwarded, an **ICMP "Fragmentation Needed" message** is sent to the sender.

7. **Copy of SKB (Packet) for Modification**:

   * Before modifying the packet (e.g., changing TTL or checksum), a **copy of the SKB** is made. This ensures that the original data is not corrupted, and the changes can be done safely.

8. **TTL Decrease**:

   * The **TTL** is decreased (decremented by 1) to indicate that the packet has passed through one router. This is done by **`ip_decrease_ttl()`**.

9. **ICMP Redirect Message**:

   * If the routing entry suggests that a **redirect** is needed (for example, if the route is no longer optimal), an **ICMP Redirect** message is sent to inform the sender to update its route.

10. **Set Priority Based on TOS (Type of Service)**:

    * The **priority** of the packet is set based on the **TOS** field of the IP header. This is used for **Quality of Service (QoS)** in networks.

11. **Forwarding the Packet**:

    * Finally, the **`ip_forward_finish()`** method is called to complete the forwarding process:

      * It **updates the statistics** of the router.
      * If the packet has **IP options** (e.g., source routing), they are processed by **`ip_forward_options()`**.
      * If no IP options are present, the packet is passed to the **output method** (`dst_output(skb)`) to be sent out of the router.

---

### **Summary of Main Points**:

* LRO Packets**: Dropped if they are larger than MTU.
* Router Alert**: If present, sent to all raw sockets.
* TTL Check**: If TTL <= 1, packet is discarded and ICMP "Time Exceeded" sent.
* Strict Routing**: If strict routing fails, ICMP "Destination Unreachable" is sent.
* MTU Check**: If packet exceeds MTU and can't be fragmented, ICMP "Fragmentation Needed" is sent.
* SKB Copy**: Created to safely modify the packet without corrupting original data.
* Decrement TTL**: Each router decreases the TTL by 1.
* ICMP Redirect**: Sent if routing suggests a better path.
* Set Priority**: Packet's priority is set based on TOS field.
* Forwarding**: The packet is forwarded to the appropriate output device.


