IPV4

id: Identification of the IPv4 header. The id field is important for fragmentation: when
fragmenting an SKB, the id value of all the fragments of that SKB should be the same.
Reassembling fragmented packets is done according to the id of the fragments.


frag_off: The fragment offset, a 16-bit field. The lower 13 bits are the offset of the fragment.
In the first fragment, the offset is 0. The offset is measured in units of 8 bytes. The higher 3 bits
are the flags:
â€¢001 is MF (More Fragments). It is set for all fragments, except the last one.
â€¢010 is DF (Donâ€™t Fragment).
â€¢100 is CE (Congestion).
See the IP_MF, IP_DF, and IP_CE flags declaration in include/net/ip.h.

ttl: Time To Live: this is a hop counter. Each forwarding node decreases the ttl by 1. When
it reaches 0, the packet is discarded, and a time exceeded ICMPv4 message is sent back; this
avoids packets from being forwarded endlessly, for this reason or another.


The **Type of Service (ToS)** field in the IPv4 header specifies **how the packet should be handled** by routersâ€”its priority, delay requirements, throughput needs, reliability, etc.

Originally, ToS was an 8-bit field, but it has evolved over time.
Letâ€™s go through both the **old interpretation** and the **modern one (DSCP/ECN)**.

---

# âœ… **Original IPv4 Type of Service (RFC 791)**

This is the classical structure:

```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   PRECEDENCE   |D|T|R|0|0|0|
+---+---+---+---+---+---+---+---+
```

### 1) **3-bit Precedence**

Indicates priority of the datagram.

| Value | Meaning              |
| ----- | -------------------- |
| 000   | Routine              |
| 001   | Priority             |
| 010   | Immediate            |
| 011   | Flash                |
| 100   | Flash Override       |
| 101   | CRITIC/ECP           |
| 110   | Internetwork Control |
| 111   | Network Control      |

Higher value = higher priority.

---

### 2) **D, T, R flags (1 bit each)**

| Bit | Meaning     | What it asks routers to do |
| --- | ----------- | -------------------------- |
| D   | Delay       | Prefer low delay           |
| T   | Throughput  | Prefer high throughput     |
| R   | Reliability | Prefer high reliability    |

Only one of these was supposed to be set at once.

---

### 3) Last 3 bits: Always zero (unused)

---

# âŒ This original ToS is **obsolete**

Routers do NOT use these bits anymore.
Instead, they use the **DSCP/ECN** interpretation defined in RFC 2474 and RFC 3168.

---

# ğŸŸ© Modern meaning of the Type of Service byte

The 8-bit ToS field was **redefined**:

```
+-----------------------+------------+
|        DSCP (6 bits)  |  ECN (2 bits) |
+-----------------------+------------+
```

---

# âœ… **1. DSCP (Differentiated Services Code Point) â€“ 6 bits**

Used for **QoS (Quality of Service)** classification.
Routers use DSCP to decide queueing, scheduling, and priority.

Example DSCP values:

| DSCP (bits) | Name                      | Purpose                    |
| ----------- | ------------------------- | -------------------------- |
| 000000      | BE (Best Effort)          | Normal traffic             |
| 101110      | EF (Expedited Forwarding) | Low loss, low delay (VoIP) |
| 001010      | AF11                      | Assured Forwarding         |
| 010010      | AF21                      | Assured Forwarding         |
| 011010      | AF31                      | Assured Forwarding         |

---

# âœ… **2. ECN (Explicit Congestion Notification) â€“ 2 bits**

Used for **active congestion control** without dropping packets.

| ECN bits | Meaning                |
| -------- | ---------------------- |
| 00       | Not ECN-capable        |
| 01       | ECN-capable transport  |
| 10       | ECN-capable transport  |
| 11       | Congestion encountered |

TCP uses this to reduce data rate before queues overflow.

---

# ğŸŸ¦ So what is â€œType of Serviceâ€ today?

Even though the IPv4 header still labels this byte as **Type of Service**, its meaning is:

> **Upper 6 bits = DSCP (QoS class)**
> **Lower 2 bits = ECN (congestion signaling)**

The old ToS meaning (precedence, delay, throughput, reliability) is no longer used.

---

# âœ” Final Summary

### **Original (obsolete) ToS field:**

* **3 bits**: Precedence
* **1 bit**: Minimize delay
* **1 bit**: Maximize throughput
* **1 bit**: Maximize reliability
* **3 bits**: unused

### **Modern ToS field:**

* **6 bits**: DSCP (QoS classification)
* **2 bits**: ECN (congestion notification)








# âœ… **Context**

When an Ethernet frame arrives (e.g., from a NIC):

* The NIC driver hands the frame to the kernel network stack.
* The frame has an **Ethernet header**, which contains a **EtherType** field (2 bytes):

```
0x0800 â†’ IPv4
0x86DD â†’ IPv6
0x0806 â†’ ARP
0x8847 â†’ MPLS
...
```

This EtherType value tells the kernel **which protocol handler should process the payload**.

---

# ğŸŸ¦ **How Linux Registers IPv4 Packet Handler**

You saw this:

```c
static struct packet_type ip_packet_type __read_mostly = {
    .type = cpu_to_be16(ETH_P_IP),
    .func = ip_rcv,
};
```

Letâ€™s decode it:

### âœ” `.type = cpu_to_be16(ETH_P_IP)`

ETH_P_IP is defined as:

```c
#define ETH_P_IP 0x0800
```

`cpu_to_be16()` ensures the constant is stored in **big-endian**, because EtherType on the wire is big-endian.

So Linux is saying:

> â€œIf you see a frame whose EtherType == 0x0800 (IPv4), call ip_rcv().â€

### âœ” `.func = ip_rcv`

`ip_rcv()` is the **IPv4 receive handler** â€” the entry point for the IPv4 Rx path.

---

# ğŸŸ© **Registering the handler: dev_add_pack()**

In `inet_init()` (IPv4 initialization):

```c
dev_add_pack(&ip_packet_type);
```

This function registers `ip_packet_type` in the kernelâ€™s **packet handler list**.

Now the network stack knows:

| EtherType | Handler      |
| --------- | ------------ |
| 0x0800    | **ip_rcv()** |
| 0x86DD    | ipv6_rcv()   |
| 0x0806    | arp_rcv()    |
| â€¦         | many others  |

---

# ğŸŸ§ **What happens when an IPv4 frame arrives?**

NIC driver â†’ `netif_rx()` â†’ kernel networking core

The kernel:

1. Reads the Ethernet header
2. Extracts the EtherType = e.g. **0x0800**
3. Searches registered protocol handlers in the `ptype_base` list
4. Finds the one with `.type = ETH_P_IP`
5. Calls:

```
ip_rcv(skb, dev, packet_type, orig_dev);
```

This begins the **IPv4 receive path**.

---

# ğŸŸ¦ **What happens inside ip_rcv()?**

(Youâ€™ll see this next in your reading)

`ip_rcv()`:

1. Validates the IPv4 header (checksum, version)
2. Checks packet length
3. Handles fragmentation (if any)
4. Sends it to LOCAL delivery or FORWARDING path:

* If destination IP == local machine â†’ goes to transport layer (TCP/UDP/ICMP)
* Otherwise â†’ may be forwarded (router mode)

---

# ğŸŸ¨ **Why this matters**

Understanding the registration of:

```c
dev_add_pack(&ip_packet_type);
```

is crucial because **this is how Linux knows which function should process which packet**, based on protocol.

---

# ğŸŸ© Summary

| Layer              | Data Type          | Kernel Mechanism                   |
| ------------------ | ------------------ | ---------------------------------- |
| Layer 2 (Ethernet) | EtherType = 0x0800 | Registered using `dev_add_pack()`  |
| Layer 3 (IPv4)     | IPv4 packet        | Handled by `ip_rcv()`              |
| Layer 4 (TCP/UDP)  | Transport headers  | Dispatched after `ip_rcv_finish()` |

---

If you want, I can walk you through **the full IPv4 receive path** step-by-step, including:

* `ip_rcv()`
* `ip_rcv_finish()`
* routing decision
* passing to TCP / UDP / ICMP


When forwarding, the kernel removes only the old L2 header, keeps and updates the L3 (IP) header, and then creates a NEW L2 header for the next hop.

So your confusion comes from thinking L2/L3 headers are only â€œread.â€
In reality:

L2 header is always stripped and rebuilt per hop.

L3 header stays (with some updates like TTL, checksum).







Between the ip_rcv() method and the ip_rcv_finish() method is the NF_INET_PRE_ROUTING
netfilter hook, invoked by calling the NF_HOOK macro

The netfilter subsystem
allows you to register callbacks in five points along the journey of a packet in the network stack. These points will be
mentioned by their names shortly. The reason for adding the netfilter hooks is to enable loading the netfilter kernel
modules at runtime.

the NF_HOOK_COND macro includes a Boolean parameter (the last
parameter), which must be true for the hook to be executed


















