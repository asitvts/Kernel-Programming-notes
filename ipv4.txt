IPV4

id: Identification of the IPv4 header. The id field is important for fragmentation: when
fragmenting an SKB, the id value of all the fragments of that SKB should be the same.
Reassembling fragmented packets is done according to the id of the fragments.


frag_off: The fragment offset, a 16-bit field. The lower 13 bits are the offset of the fragment.
In the first fragment, the offset is 0. The offset is measured in units of 8 bytes. The higher 3 bits
are the flags:
â€¢001 is MF (More Fragments). It is set for all fragments, except the last one.
â€¢010 is DF (Donâ€™t Fragment).
â€¢100 is CE (Congestion).
See the IP_MF, IP_DF, and IP_CE flags declaration in include/net/ip.h.

ttl: Time To Live: this is a hop counter. Each forwarding node decreases the ttl by 1. When
it reaches 0, the packet is discarded, and a time exceeded ICMPv4 message is sent back; this
avoids packets from being forwarded endlessly, for this reason or another.


The **Type of Service (ToS)** field in the IPv4 header specifies **how the packet should be handled** by routersâ€”its priority, delay requirements, throughput needs, reliability, etc.

Originally, ToS was an 8-bit field, but it has evolved over time.
Letâ€™s go through both the **old interpretation** and the **modern one (DSCP/ECN)**.

---

# âœ… **Original IPv4 Type of Service (RFC 791)**

This is the classical structure:

```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   PRECEDENCE   |D|T|R|0|0|0|
+---+---+---+---+---+---+---+---+
```

### 1) **3-bit Precedence**

Indicates priority of the datagram.

| Value | Meaning              |
| ----- | -------------------- |
| 000   | Routine              |
| 001   | Priority             |
| 010   | Immediate            |
| 011   | Flash                |
| 100   | Flash Override       |
| 101   | CRITIC/ECP           |
| 110   | Internetwork Control |
| 111   | Network Control      |

Higher value = higher priority.

---

### 2) **D, T, R flags (1 bit each)**

| Bit | Meaning     | What it asks routers to do |
| --- | ----------- | -------------------------- |
| D   | Delay       | Prefer low delay           |
| T   | Throughput  | Prefer high throughput     |
| R   | Reliability | Prefer high reliability    |

Only one of these was supposed to be set at once.

---

### 3) Last 3 bits: Always zero (unused)

---

# âŒ This original ToS is **obsolete**

Routers do NOT use these bits anymore.
Instead, they use the **DSCP/ECN** interpretation defined in RFC 2474 and RFC 3168.

---

# ğŸŸ© Modern meaning of the Type of Service byte

The 8-bit ToS field was **redefined**:

```
+-----------------------+------------+
|        DSCP (6 bits)  |  ECN (2 bits) |
+-----------------------+------------+
```

---

# âœ… **1. DSCP (Differentiated Services Code Point) â€“ 6 bits**

Used for **QoS (Quality of Service)** classification.
Routers use DSCP to decide queueing, scheduling, and priority.

Example DSCP values:

| DSCP (bits) | Name                      | Purpose                    |
| ----------- | ------------------------- | -------------------------- |
| 000000      | BE (Best Effort)          | Normal traffic             |
| 101110      | EF (Expedited Forwarding) | Low loss, low delay (VoIP) |
| 001010      | AF11                      | Assured Forwarding         |
| 010010      | AF21                      | Assured Forwarding         |
| 011010      | AF31                      | Assured Forwarding         |

---

# âœ… **2. ECN (Explicit Congestion Notification) â€“ 2 bits**

Used for **active congestion control** without dropping packets.

| ECN bits | Meaning                |
| -------- | ---------------------- |
| 00       | Not ECN-capable        |
| 01       | ECN-capable transport  |
| 10       | ECN-capable transport  |
| 11       | Congestion encountered |

TCP uses this to reduce data rate before queues overflow.

---

# ğŸŸ¦ So what is â€œType of Serviceâ€ today?

Even though the IPv4 header still labels this byte as **Type of Service**, its meaning is:

> **Upper 6 bits = DSCP (QoS class)**
> **Lower 2 bits = ECN (congestion signaling)**

The old ToS meaning (precedence, delay, throughput, reliability) is no longer used.

---

# âœ” Final Summary

### **Original (obsolete) ToS field:**

* **3 bits**: Precedence
* **1 bit**: Minimize delay
* **1 bit**: Maximize throughput
* **1 bit**: Maximize reliability
* **3 bits**: unused

### **Modern ToS field:**

* **6 bits**: DSCP (QoS classification)
* **2 bits**: ECN (congestion notification)








# âœ… **Context**

When an Ethernet frame arrives (e.g., from a NIC):

* The NIC driver hands the frame to the kernel network stack.
* The frame has an **Ethernet header**, which contains a **EtherType** field (2 bytes):

```
0x0800 â†’ IPv4
0x86DD â†’ IPv6
0x0806 â†’ ARP
0x8847 â†’ MPLS
...
```

This EtherType value tells the kernel **which protocol handler should process the payload**.

---

# ğŸŸ¦ **How Linux Registers IPv4 Packet Handler**

You saw this:

```c
static struct packet_type ip_packet_type __read_mostly = {
    .type = cpu_to_be16(ETH_P_IP),
    .func = ip_rcv,
};
```

Letâ€™s decode it:

### âœ” `.type = cpu_to_be16(ETH_P_IP)`

ETH_P_IP is defined as:

```c
#define ETH_P_IP 0x0800
```

`cpu_to_be16()` ensures the constant is stored in **big-endian**, because EtherType on the wire is big-endian.

So Linux is saying:

> â€œIf you see a frame whose EtherType == 0x0800 (IPv4), call ip_rcv().â€

### âœ” `.func = ip_rcv`

`ip_rcv()` is the **IPv4 receive handler** â€” the entry point for the IPv4 Rx path.

---

# ğŸŸ© **Registering the handler: dev_add_pack()**

In `inet_init()` (IPv4 initialization):

```c
dev_add_pack(&ip_packet_type);
```

This function registers `ip_packet_type` in the kernelâ€™s **packet handler list**.

Now the network stack knows:

| EtherType | Handler      |
| --------- | ------------ |
| 0x0800    | **ip_rcv()** |
| 0x86DD    | ipv6_rcv()   |
| 0x0806    | arp_rcv()    |
| â€¦         | many others  |

---

# ğŸŸ§ **What happens when an IPv4 frame arrives?**

NIC driver â†’ `netif_rx()` â†’ kernel networking core

The kernel:

1. Reads the Ethernet header
2. Extracts the EtherType = e.g. **0x0800**
3. Searches registered protocol handlers in the `ptype_base` list
4. Finds the one with `.type = ETH_P_IP`
5. Calls:

```
ip_rcv(skb, dev, packet_type, orig_dev);
```

This begins the **IPv4 receive path**.

---

# ğŸŸ¦ **What happens inside ip_rcv()?**

(Youâ€™ll see this next in your reading)

`ip_rcv()`:

1. Validates the IPv4 header (checksum, version)
2. Checks packet length
3. Handles fragmentation (if any)
4. Sends it to LOCAL delivery or FORWARDING path:

* If destination IP == local machine â†’ goes to transport layer (TCP/UDP/ICMP)
* Otherwise â†’ may be forwarded (router mode)

---

# ğŸŸ¨ **Why this matters**

Understanding the registration of:

```c
dev_add_pack(&ip_packet_type);
```

is crucial because **this is how Linux knows which function should process which packet**, based on protocol.

---

# ğŸŸ© Summary

| Layer              | Data Type          | Kernel Mechanism                   |
| ------------------ | ------------------ | ---------------------------------- |
| Layer 2 (Ethernet) | EtherType = 0x0800 | Registered using `dev_add_pack()`  |
| Layer 3 (IPv4)     | IPv4 packet        | Handled by `ip_rcv()`              |
| Layer 4 (TCP/UDP)  | Transport headers  | Dispatched after `ip_rcv_finish()` |

---

If you want, I can walk you through **the full IPv4 receive path** step-by-step, including:

* `ip_rcv()`
* `ip_rcv_finish()`
* routing decision
* passing to TCP / UDP / ICMP


When forwarding, the kernel removes only the old L2 header, keeps and updates the L3 (IP) header, and then creates a NEW L2 header for the next hop.

So your confusion comes from thinking L2/L3 headers are only â€œread.â€
In reality:

L2 header is always stripped and rebuilt per hop.

L3 header stays (with some updates like TTL, checksum).







Between the ip_rcv() method and the ip_rcv_finish() method is the NF_INET_PRE_ROUTING
netfilter hook, invoked by calling the NF_HOOK macro

The netfilter subsystem
allows you to register callbacks in five points along the journey of a packet in the network stack. These points will be
mentioned by their names shortly. The reason for adding the netfilter hooks is to enable loading the netfilter kernel
modules at runtime.

the NF_HOOK_COND macro includes a Boolean parameter (the last
parameter), which must be true for the hook to be executed




if (iph->ihl < 5 || iph->version != 4)
goto inhdr_error;

if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))
goto inhdr_error;

return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
ip_rcv_finish);

When the registered netfilter hook method returns NF_DROP, it means that the packet should be dropped, and the
packet traversal does not continue. When the registered netfilter hook returns NF_STOLEN, it means that the packet
was taken over by the netfilter subsystem, and the packet traversal does not continue



âœ… What NF_STOLEN Really Means

When your hook function returns NF_STOLEN, you are telling Netfilter:

â€œDo NOT continue packet processing.
I have taken responsibility for this packet.
I will free it, modify it, retransmit it, queue it, or otherwise dispose of it myself.â€

Because you now own the packet, Netfilter will:

NOT pass it to remaining hooks

NOT reinject it

NOT free it

NOT forward, drop, or deliver it

You must eventually decide what to do with the packet.

â— What happens if you return NF_STOLEN but do nothing?

You will create a memory leak, because Netfilter will assume â€œthe handler is managing the packet now.â€

This is why NF_STOLEN is used only in special situations.




If there is no dst attached to the SKB, a lookup in the routing subsystem is performed by the
ip_route_input_noref() method. If the lookup fails, the packet is dropped. Note that handling multicast packets is
different than handling unicast packets
Now a check is performed to see whether the IPv4 header includes options. Because the length of the IPv4 header
(ihl) is measured in multiples of 4 bytes, if it is greater than 5 this means that it includes options, so the ip_rcv_options()
method should be invoked to handle these options.



The IP options field of the IPv4 header is optional and is not often used for security reasons and because of processing
overhead. Which options might be helpful? Suppose, for example, that your packets are being dropped by a certain
firewall. You may be able to specify a different route with the Strict or Loose Source Routing options. Or if you want to
find out the packetsâ€™ path to some destination addresses, you can use the Record Route option.







## **Two kinds of IP options**

### **1. Single-byte options**

These have **only the option type** byte:

* **End of Option List (EOL)**
* **No Operation (NOP)**

### **2. Multibyte options**

Format:

```
| Type | Length | Pointer | Option Data... |
```

* **Type** = what the option is
* **Length** = total size of this option
* **Pointer** = offset into the data (used by RR, Timestamp, etc.)
* **Option Data** = e.g., timestamps, IP addresses, route entries

---

# âœ… **Copied Flag**

Inside the option type byte:

* If **copied flag = 1** â†’ option must be copied into **all fragments**
* If **copied flag = 0** â†’ option only appears in **the first fragment**

The kernel uses **IPOPT_COPIED(option)** to check this.

In fragmentation, the kernel:

* **keeps** options that must be copied
* **replaces** non-copied options with **NOP** in other fragments

---

# âœ… **Option Classes**

The option type byte also contains a **2-bit class field**:

| Bits | Meaning               |
| ---- | --------------------- |
| 00   | Control (most common) |
| 01   | Reserved1             |
| 10   | Debug/measurement     |
| 11   | Reserved2             |

In Linux:

* Only **IPOPT_TIMESTAMP** is a measurement option.
* Most others (like RR, SSRR, LSRR) are **control** options.

---

# âœ… **Option Number (0â€“31)**

This identifies the specific option type.
Not all numbers are used; Linux implements only some of them.

---
+------------------------------------------------------+
|                    IP OPTIONS                        |
+------------------------------------------------------+
| Option 1 | Option 2 | Option 3 | ... | Option N |
+------------------------------------------------------+
Each option has one of these two formats:



Either this 
+----------------------+
| Option Type (1 byte) |
+----------------------+
Used only for:

0 â†’ End of Option List (EOL)

1 â†’ No Operation (NOP)

No length, no pointer, no data.


or 


+------------------------------------------------------------------------+
|  Option Type (8 bits)  |  Length (8 bits)  | Pointer (8 bits)         |
+------------------------------------------------------------------------+
|                     Option Data (variable length)                      |
+------------------------------------------------------------------------+




inside option type byte


      +--------+----------------------------------------------+
      |Copied (1 bit)  |   Class (2 bits)  |  Number (5 bits) |
      +--------+----------------------------------------------+







basically 

                           MULTI-BYTE OPTION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Option Type                          â”‚
â”‚ 7        6 5           4 3 2 1 0                            â”‚
â”‚+----------+--------------+---------------------------------+â”‚
â”‚| Copied=0 | Class=00     | Number=xxxxx                    |â”‚
â”‚+----------+--------------+---------------------------------+â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Length (total bytes)   â”‚  1 byte
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pointer / Offset       â”‚  1 byte
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Option Data (varies)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜




















