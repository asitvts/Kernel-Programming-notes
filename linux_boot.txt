# Complete, step-by-step Linux boot process (including Real Mode → Protected/Long Mode on x86)

You asked for **every single small step** — I’ll walk through the full boot chain for typical x86 systems (BIOS/MBR and UEFI paths), show what the kernel does while *starting in real mode and switching to protected/long mode*, and then follow the kernel → initramfs → userspace transition (init/systemd, device discovery, targets). I’ll also explain the low-level CPU mode concepts (real vs protected vs long mode), exact CPU control register changes, and the typical bootloader → kernel interactions. This is long and detailed — read with coffee. ☕️

---

## High-level overview (one line)

Power on → firmware (BIOS/UEFI) → bootloader (MBR/GRUB or EFI stub) → kernel decompression + CPU mode switch (real → protected → long) → kernel init (initramfs) → pivot to real root → userspace init (/sbin/init, typically systemd) → system targets/services → login.

---

# Part A — Preliminaries: CPU modes explained (important to understand later)

### Real mode (x86)

* The mode the CPU starts in after reset.
* 16-bit mode with 20-bit physical addressing via segment:offset (segment * 16 + offset). So only 1 MiB addressable directly (with A20 disabled historically).
* No memory protection, no virtual memory, no paging, no privilege rings.
* Interrupt Vector Table (IVT) at physical 0x0000:0x0000 (256 vectors × 4 bytes each).
* Used for BIOS interrupt services (INT 10h, INT 13h, etc.).

### Protected mode (x86, 32-bit)

* Enabled by setting PE bit in control register CR0.
* Supports:

  * Segmentation with segment descriptors stored in Global Descriptor Table (GDT) and Local Descriptor Table (LDT).
  * Privilege levels (Ring 0..3).
  * Paging (virtual memory) can be enabled after segments.
  * 32-bit addressing (flat models commonly used).
* Requires loading a GDT, then setting CR0.PE=1, then doing a far jump to flush prefetch and load new CS with selector for protected code.

### Long mode (x86_64, 64-bit)

* Enabled on x86_64 processors via MSR `IA32_EFER` (set LME bit), switch to protected mode, enable paging (with PAE/4-level page tables), then enable long mode (LMA) by setting EFER.LME and enabling paging; finally do a far jump into the 64-bit entry point.
* Once in long mode:

  * 64-bit addressing via 4-level page tables (PML4, PDPT, PD, PT).
  * Segmentation is mostly unused (CS base is forced to 0 in canonical mapping) except FS/GS base.
  * Full 64-bit general registers.

**Key low-level control registers & MSRs used during switching**

* `CR0` (bit 0 = PE) — enables protected mode.
* `CR3` — page directory base (PDBR); points to top-level page table frame.
* `CR4` — control extensions (e.g., PAE bit for physical address extension).
* `IA32_EFER` MSR — LME (Long Mode Enable), LMA is visible when paging is enabled.
* `A20` line — must be enabled to access beyond 1 MiB in real mode bootstrap.

---

# Part B — From power-on to firmware (firmware stage)

1. **Power applied / Reset**

   * CPU reset vector is set (for x86: IP = 0xFFF0, CS=0xF000 — physical address 0xFFFF0, within BIOS ROM area).
   * CPU starts in **real mode**.
   * Internal CPU state: real mode, interrupts disabled by firmware initially, A20 line may be disabled.

2. **POST (Power-On Self Test)**

   * Firmware (BIOS) performs hardware tests, initializes chipset, memory detection, peripheral init.
   * Firmware prints POST messages to debug/serial/console if present.

3. **Firmware boot policy**

   * Boot device order configured (BIOS CMOS settings or UEFI settings).
   * If **UEFI**: the firmware runs the EFI application(s) from the EFI system partition (FAT) — e.g., shim → grubx64.efi, or directly vmlinuz if kernel has EFI stub.
   * If **BIOS/legacy**: firmware reads the first sector (MBR) from the chosen boot device into memory and jumps to it.

---

# Part C — Bootloader stage (BIOS/MBR vs UEFI differences)

## BIOS / MBR path (legacy)

4. **Load MBR (first 512 bytes)**

   * BIOS reads LBA 0 into memory 0x7C00 and transfers control to it (real mode).
   * MBR contains:

     * Boot code (typically 446 bytes),
     * Partition table (64 bytes),
     * Boot signature (0x55AA).
   * The MBR boot code typically loads a stage1 bootloader (like GRUB stage1) from disk.

5. **Stage1 → Stage1.5 → Stage2** (GRUB classic example)

   * Stage1 (in MBR) is tiny; it loads stage1.5 (if present) or stage2 from known filesystem areas.
   * Stage2 (GRUB) understands filesystems, reads `/boot/grub/grub.cfg`, shows menu, loads kernel image (vmlinuz-...) and initrd/initramfs, passes kernel command line.
   * GRUB can run in **real**, **protected**, or **virtual 8086** modes depending on implementation. For multiboot/kernels it typically loads the kernel into memory and uses BIOS services until it hands off.

## UEFI path

6. **UEFI loads an EFI executable**

   * Firmware loads an `.efi` binary (e.g., grubx64.efi) and runs it in **long/flat mode** supported by EFI (UEFI runs in 32/64-bit protected mode, not real).
   * The EFI application reads files from the EFI System Partition (ESP), presents boot menu, and loads kernel+initramfs or an EFI boot manager stub.
   * If kernel supports EFI stub, the EFI firmware may load `vmlinuz` directly and call its EFI entry point (no GRUB needed).

---

# Part D — Bootloader → kernel handoff

7. **Bootloader loads kernel image and initramfs**

   * Kernel image: `vmlinuz-*` (compressed kernel image) or an EFI stub capable vmlinuz.
   * Initramfs/initrd: initial ram filesystem archive (cpio compressed) that kernel will mount early.
   * Bootloader sets up kernel command line (e.g., `root=/dev/sda2 rw quiet splash`), and provides memory map (BIOS e820), kernel parameters, and, for EFI, passes an EFI runtime/systems table.

8. **Bootloader jumps to kernel entry**

   * **On BIOS systems**, GRUB typically loads the kernel into memory and then uses a small real-mode stub in the kernel image to start the kernel (kernel expects to be started in real mode).
   * **On UEFI systems**, the firmware already runs in protected/long mode and may call the kernel EFI entry directly in 64-bit mode if kernel EFI stub supports it; the kernel then may skip some legacy real-mode steps.

---

# Part E — Kernel bootstrap (very detailed; x86 BIOS path assumed; highlights for UEFI noted)

> **Important:** The compressed Linux kernel (`bzImage` for x86) contains a small real-mode bootstrap that runs first. The kernel arrives compressed and includes a setup header and a small 16-bit setup code, then the compressed 32/64-bit payload.

9. **Kernel real-mode setup code runs (16-bit)**

   * The kernel image’s **setup** code (setup.S / `boot/` code) is 16-bit and runs in real mode because older BIOSes start that way.
   * Tasks performed by setup code:

     * Parse the kernel setup header (verify bootsignature).
     * Initialize basic hardware state expected by kernel (clearing BSS, etc.).
     * Parse the bootloader-provided information (e.g., E820 memory map, kernel parameters).
     * Reserve necessary memory regions.
     * **Enable A20** gate if not already enabled (so it can access memory above 1 MiB).
     * Copy the compressed kernel payload from where the bootloader put it into high memory, prepare for decompression.

10. **Kernel decompression**

    * The kernel decompressor runs (still 16-bit/real-mode or a small mode-switch) and decompresses the kernel image into memory. The decompressed kernel includes the real startup code that will initialize protected mode transition.
    * After decompression, control moves to a small C/assembly bootstrap inside the kernel (often compiled as 32-bit code).

11. **Minimal protected-mode environment / switch preparation**

    * Kernel code sets up data structures necessary to transition into protected mode:

      * A minimal GDT is created in memory with descriptors for code, data, and possibly TSS.
      * An IDT may be prepared (though CPU uses default interrupts).
      * Page tables are not necessarily set yet (switch to protected mode first).
    * On x86_64 kernels the boot code will prepare to switch to long mode; on x86 kernels it will set up protected mode.

12. **Enabling Protected Mode (32-bit kernel path) — sequence of instructions (conceptual)**

    * Load the GDT: `lgdt [gdt_descriptor]`.
    * Set PE bit in CR0: read CR0, OR with 1, write CR0: `mov eax, cr0; or eax, 1; mov cr0, eax`.
    * Do a far jump to flush the instruction prefetch and load new `CS` selector pointing to protected-mode code segment: `jmp 0x08:protected_entry`.
    * From there, segmentation and protected mode semantics apply.

13. **x86_64: to Long Mode (64-bit) — typical sequence**

    * Kernel starts in a legacy compatibility section that sets up protected mode with paging using PAE (or sets up page tables appropriate for entering long mode).

    * Steps:

      * Enable Physical Address Extension (set CR4.PAE = 1) if needed.
      * Prepare page tables that map the kernel into the higher half (canonical addresses). Create PML4, PDPT, PD, PT entries as needed.
      * Load CR3 with the physical address of the PML4 table.
      * Set EFER.LME bit in MSR `IA32_EFER` to enable Long Mode.
      * Enable paging by setting CR0.PG = 1 and keeping CR0.PE = 1.
      * Do a far jump to the 64-bit kernel entry point; the CPU switches to long mode (LMA) and the new CS is a 64-bit code segment.

    * Note: On UEFI systems the firmware may already be in 64-bit mode and call the kernel's EFI stub directly in long mode; the kernel may still prepare its own page tables and switch to its canonical mapping.

14. **After entering protected/long mode**

    * Kernel sets up important kernel structures:

      * Kernel page tables and memory management subsystem (`mm`).
      * Kernel stack(s) for each CPU.
      * CPU features detection (CPUID).
      * Initialize kernel subsystems in order: `sched`, `irq`, `time`, `mm`, `slab`, etc.
      * Initialize drivers compiled into kernel (not modules).
    * The kernel mounts an **initial root filesystem** from the compressed initramfs image (ramfs/tmpfs cpio archive) or uses an initial RAM disk (older style) provided by the bootloader.

15. **Initramfs / initrd handling**

    * If `initramfs` is provided (embedded cpio archive), the kernel unpacks it into a tmpfs and sets it up as the initial root (`rootfs`).
    * If `initrd` was used, it's typically loaded as a block device or an unpacked ramfs; modern kernels prefer initramfs (cpio).
    * Kernel executes `/init` (or `/linuxrc`) from initramfs as PID 1 in userspace-like environment (but still early userspace).

---

# Part F — Kernel takes over hardware, device enumeration, driver loading

16. **Kernel probes hardware and initializes drivers**

    * Kernel enumerates buses (PCI, ISA), detects devices, registers drivers.
    * Built-in drivers initialize devices (console, disk controllers) required to mount root.
    * For devices whose drivers are modules, the kernel may defer loading until udev invokes modprobe.

17. **Mounting the real root vs staying in initramfs**

    * If kernel command line `root=` points to a device, and kernel can mount it directly (driver available), kernel may mount that root filesystem; otherwise it stays in initramfs so the initramfs can load modules and prepare root.

18. **Purpose of initramfs**

    * Provide minimal userspace to:

      * Load kernel modules (e.g., disk controller, filesystem, LVM, RAID).
      * Assemble LVM/MD arrays.
      * Decrypt disks (LUKS) if necessary.
      * Mount the real root filesystem (`/dev/mapper/vg-root` etc).
    * Typical initramfs scripts call `switch_root` (or `pivot_root`) to change from the ramfs root to the real root.

19. **`pivot_root` vs `switch_root`**

    * `pivot_root(new_root, put_old)` rearranges root and mountpoints; used by older initscripts.
    * `switch_root` (busybox/systemd's early init) is simpler: mounts new root and then `execv`'s the new `/sbin/init` from it. After `switch_root`, the initramfs is discarded (unmounted), freeing memory.

---

# Part G — `init` process (userspace) and systemd

20. **Kernel spawns `/init` (PID 1)**

    * Kernel executes `/init` from the new root (after `switch_root`) or from initramfs if still there.
    * If no `/init` exists, kernel tries `/sbin/init`, `/bin/init`, `/bin/sh` in that order.

21. **Common modern init: `systemd`**

    * If `systemd` is present as `/sbin/init`, it becomes PID 1.
    * `systemd` reads `/etc/fstab`, kernel command line, and its unit files in `/usr/lib/systemd/system` and `/etc/systemd/system`.
    * It creates cgroups for services and starts services in parallel according to dependencies.
    * `systemd` targets map to SysV runlevels (`graphical.target`, `multi-user.target`, `rescue.target`, etc).

22. **Older init (SysVinit) / BusyBox init**

    * SysVinit executes `/etc/inittab` and runs `/etc/rc.d/` scripts per runlevel.
    * BusyBox provides a small init suitable for embedded systems.

23. **udev (device manager in userspace)**

    * `udevd` reads kernel uevents (hotplug notifications). Kernel emits uevents when devices appear.
    * `udev` creates `/dev` device nodes dynamically, writes persistent names (`/dev/disk/by-uuid/...`), triggers `modprobe` to load modules for detected hardware.
    * This is how block devices become available for mounting.

24. **Mounting filesystems and `fstab` processing**

    * `systemd` or init runs `fsck` if `pass` field in `/etc/fstab` says to check.
    * Filesystems declared in `/etc/fstab` are mounted, swap activated, etc.

25. **Network initialization**

    * Network manager or `systemd-networkd`/NetworkManager configures network interfaces, DHCP, static IPs.
    * Some network critical services may be started later depending on target dependencies.

26. **Graphical environment and login**

    * `getty` services spawn virtual terminals (tty1..tty6) for console login.
    * Graphical target starts `display-manager` (GDM, SDDM, LightDM) which spawns Xorg/Wayland and login greeter.
    * Multi-user target without graphical goes to CLI logins.

---

# Part H — Summary of x86 CPU mode transitions (concise, step-by-step)

**BIOS → vmlinuz (bzImage) boot (x86/32 or x86_64 compressed kernel)**

1. Firmware (BIOS) loads MBR, MBR loads GRUB stage1, GRUB loads vmlinuz and initramfs.
2. GRUB passes memory map, video mode, kernel cmdline, and jumps to kernel 16-bit setup entry at 0x10000 or similar.
3. Kernel 16-bit setup code:

   * Parse boot params,
   * Enable A20,
   * Decompress kernel into high memory.
4. Boot stubs create a minimal GDT and other tables.
5. Enter protected mode:

   * `lgdt [gdt]`
   * `mov eax, cr0; or eax, 1; mov cr0, eax`
   * `ljmp $code_sel, $protected_entry`
6. For x86_64: prepare PML4 & page tables, set CR4.PAE, write IA32_EFER.LME, set CR3 to page table physical address, set CR0.PG=1 → CPU enters long mode on far jump to 64-bit entry.
7. Kernel initializes `mm`, `sched`, `irq`, sets up `initramfs`, mounts it and executes `/init`.
8. `/init` (systemd/initramfs scripts) loads modules, assembles root devices, mounts real root, `switch_root` to new root.
9. Start PID 1 `/sbin/init` (systemd) to bring up userspace.

---

# Part I — More low-level specifics (exact register changes and sample sequences)

### Enabling A20 (why)

* Real mode addressing wraps at 1 MiB; to access >1 MiB, A20 line must be enabled. The kernel’s setup code ensures A20 is enabled by calling BIOS or keyboard controller trick. On modern PCs this is usually already enabled.

### Example minimal protected-mode switch pseudo-sequence (conceptual assembly)

> This is conceptual; real kernel code handles many corner cases and CPU quirks.

```asm
; assume GDT set up at gdt_ptr (limit and base)
lgdt [gdt_ptr]

; enable protected mode
mov eax, cr0
or eax, 1    ; set PE bit
mov cr0, eax

; far jump to protected-mode code to reload CS
jmp 0x08:protected_entry

; protected_entry: (now in protected mode)
protected_entry:
  ; set data segment registers to 0x10 (data selector)
  mov ax, 0x10
  mov ds, ax
  mov es, ax
  mov fs, ax
  mov gs, ax
  mov ss, ax
  ; continue kernel init...
```

### Example x86_64 long mode entry (conceptual)

* Prepare PML4 entries so that higher-half kernel virtual addresses map to physical memory where kernel is placed.
* Enable PAE (CR4.PAE = 1).
* Load `CR3 = pml4_phys`.
* Write IA32_EFER.LME = 1 (MSR `0xC0000080`).
* Enable paging: set CR0.PG = 1.
* Far jump to 64-bit entry (selector must use a 64-bit code descriptor).

Real kernel code also sets NX bit where supported, configures stack, per-CPU data, etc.

---

# Part J — Special cases / variations

### UEFI boot differences

* UEFI runs in protected/long mode already and provides richer services (EFI runtime services, filesystem access).
* Kernel with EFI stub can be loaded directly by UEFI and started without going through 16-bit real mode steps; kernel still sets up its own page tables and enters its preferred higher half but may rely on UEFI boot services initially.

### ARM (AArch64, ARMv7) differences (brief)

* ARM does not have x86 real/protected/long modes. ARM CPUs boot in a particular exception level (EL3/EL2/EL1) depending on SoC and firmware.
* Boot sequence: ROM/bootloader (SPL) → U-Boot (on many embedded boards) → load kernel (Image or zImage) and DTB (device tree blob) → kernel decompresses and expects an initial environment (device tree provides hardware description).
* There is no segmentation; instead, ARM uses different exception levels and MMU enablement to switch to virtual memory.

### Secure Boot / Shim

* On UEFI with Secure Boot, shim (signed by Microsoft or vendor) verifies GRUB, GRUB verifies kernel, preventing tampering.

---

# Part K — After boot: what the kernel continues to do (brief)

* Maintain process scheduler and context switching.
* Handle interrupts and system calls (IDT).
* Load kernel modules on demand via `modprobe`.
* Manage devices via kernel subsystems and export events to `udev`.
* Continue to tear down initramfs once `switch_root` completes.

---

# Part L — Example timeline for a typical desktop (concise)

1. Power ON → CPU reset (real mode)
2. POST → BIOS/UEFI
3. Bootloader (GRUB/EFI) loaded
4. Bootloader loads `vmlinuz` + `initramfs` and jumps to kernel entry
5. Kernel 16-bit setup runs, enables A20, decompresses kernel
6. Kernel prepares GDT/paging, switches CPU into protected mode → (for x86_64) into long mode
7. Kernel initializes memory, drivers, mounts initramfs
8. Kernel executes `/init` from initramfs (PID 1)
9. initramfs loads modules, sets up LVM/RAID/crypt, mounts root
10. `switch_root` → exec `/sbin/init` (systemd)
11. systemd starts targets/services, `udev` populates `/dev`
12. Login prompt or graphical login appears

---

# Part M — Common boot parameters and what they do

* `root=/dev/sda1` — device to mount as root.
* `ro` / `rw` — mount root read-only or read-write initially.
* `init=/bin/bash` — run that as PID 1 (useful for recovery).
* `quiet` — reduce kernel log verbosity.
* `nomodeset` — prevent kernel video mode setting (useful for GPU issues).
* `earlyprintk` — enable early kernel log output before console driver initialized.

---

# Part N — Troubleshooting tips (practical)

* If kernel doesn’t boot: use `verbose` or remove `quiet` from kernel cmdline to see verbose boot messages.
* To debug early kernel: use `earlyprintk`, serial console, or netconsole.
* If initramfs fails to find root: ensure kernel has needed drivers (SCSI/NVMe/CPU) built-in or initramfs contains the modules.
* If UEFI secure boot blocks kernel: use shim and signed kernels or disable secure boot.

---

# Part O — Quick recap (the must-remember micro-steps)

1. CPU reset (real mode) → BIOS/UEFI.
2. BIOS: MBR → bootloader (GRUB); UEFI: EFI executable.
3. Bootloader loads kernel + initramfs and kernel cmdline.
4. Kernel 16-bit setup runs: enable A20, decompress kernel.
5. Kernel prepares GDT, page tables → set CR0.PE → protected mode → (if x86_64) enable PAE/EFER.LME → enable paging → long mode.
6. Kernel initializes `mm`, devices; mounts `initramfs` and execs `/init`.
7. Initramfs loads modules, mounts real root; `switch_root` to real root.
8. PID 1 (systemd) brings up userspace services → login.

---

If you want, I can:

* Provide the **actual kernel assembly snippets** (from `arch/x86/boot` in Linux source) showing exactly which instructions are used (I can quote and explain them), or
* Walk the same sequence **for ARM (AArch64)** with exact exception levels and device tree handling, or
* Produce a **diagram** (visual timeline) of the boot stages.

Which of those would you like next?

