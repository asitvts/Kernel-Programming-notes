
# âœ… **ARM Processor Registers â€” Detailed but Easy Explanation**

ARM (especially ARMv7 & ARMv8) follows a **load-store RISC architecture**, so registers are extremely important.
Letâ€™s break them down cleanly.

---

# ğŸ”µ **1. General Purpose Registers (GPRs)**

ARM traditionally has **16 visible registers (R0â€“R15)** in ARMv7 (32-bit).
ARMv8 (AArch64) has **31 GPRs (X0â€“X30)** â€” but first letâ€™s understand ARMv7 since it is the classic version taught everywhere.

---

# â­ **ARMv7 (32-bit) Registers**

## **R0â€“R12 â†’ General Purpose Registers**

### **Definition:**

These are **general-use registers** used for arithmetic, data storage, temporary values, function arguments, etc.

### **Easy Hinglish:**

Yeh sab **normal kaam** ke registers hote hain â€” calculations, values rakhna, temporary storage etc.

**Use cases:**

* R0â€“R3 â†’ function arguments + return values
* R4â€“R11 â†’ callee-saved registers (function ke andar preserve karne hote hain)
* R12 â†’ Intra-procedure scratch register (IP)

---

# ğŸ”µ **2. Special Purpose Registers**

## **R13 â€” SP (Stack Pointer)**

### **Definition:**

This register always points to the **top of the stack**.

### **Easy Hinglish:**

Yeh batata hai stack kahaan se start/continue ho raha hai.
Local variables, return addresses yahin store hote hain.

ARM often has **multiple stack pointers** depending on mode:

* SP_usr
* SP_svc
* SP_irq
* SP_fiq
* SP_abt
* SP_und

---

## **R14 â€” LR (Link Register)**

### **Definition:**

When a function is called (BL instruction), the **return address** is stored in R14 (LR).

### **Easy Hinglish:**

Jab function call hota hai, wapas kahan aana hai â€” yeh LR mein rakha jata hai.
C ke equivalent: return address.

Multiple LR versions per mode (LR_svc, LR_irq, etc.)

---

## **R15 â€” PC (Program Counter)**

### **Definition:**

Holds the address of the currently executing instruction + 8 bytes (because pipeline).

### **Easy Hinglish:**

PC batata hai CPU kaunsi instruction chala raha hai.
ARM pipeline ke wajah se PC always **current instruction + 8** hota hai (ARMv7).

---

# ğŸ”µ **3. CPSR â€” Current Program Status Register**

### **Definition:**

This is a **32-bit status register** that holds:

* Condition flags (NZCV)
* Interrupt disable bits (I/F)
* Processor mode bits
* State bits (ARM/Thumb/Jazelle)

### â­ Bits Explained:

| Bit       | Meaning     | Easy Hinglish                                              |
| --------- | ----------- | ---------------------------------------------------------- |
| **N**     | Negative    | Result negative laga                                       |
| **Z**     | Zero        | Result zero aaya                                           |
| **C**     | Carry       | Arithmetic carry                                           |
| **V**     | Overflow    | Signed overflow                                            |
| **I**     | IRQ disable | Normal interrupts off                                      |
| **F**     | FIQ disable | Fast interrupts off                                        |
| **T**     | Thumb state | Thumb mode active                                          |
| **M4â€“M0** | CPU mode    | Kaunsa mode active (User, System, Supervisor, IRQ, FIQ...) |

### **Easy Hinglish:**

CPSR CPU ka **status dashboard** hota hai â€” CPU kis mode mein hai, interrupts on/off, last result kaise aaya etc.

---

# ğŸ”µ **4. SPSR â€” Saved Program Status Register**

### **Definition:**

During exceptions (IRQ, FIQ, SVC), ARM stores the **previous CPSR** into SPSR.

### **Easy Hinglish:**

Exception ya interrupt aate hi CPU apna current status SPSR mein save kar deta hai, taaki return karne par purani state wapas a jaye.

Har exception mode ka **alag SPSR hota hai**:

* SPSR_irq
* SPSR_fiq
* SPSR_svc
* SPSR_abt
* SPSR_und

User mode has **no SPSR**.

---

# ğŸ”µ **5. Banked Registers**

ARM ke kuch registers **mode-specific (banked)** hote hain.

## â­ Banked registers list (ARMv7):

| Mode | Banked Registers |
| ---- | ---------------- |
| FIQ  | R8_fiqâ€“R14_fiq   |
| IRQ  | R13_irq, R14_irq |
| SVC  | R13_svc, R14_svc |
| ABT  | R13_abt, R14_abt |
| UND  | R13_und, R14_und |

### **Easy Hinglish:**

Har special mode (IRQ, FIQ) ke apne stack pointer aur link register hote hain.
FIQ mode ke pass aur bhi extra registers hote hain (R8â€“R14) taaki fast interrupt handling ho sake.

---

# ğŸŸ£ **ARMv8 (AArch64) Registers (Short Overview)**

ARMv8 (64-bit) uses:

* **X0â€“X30** (31 general purpose 64-bit registers)
* **SP** (stack pointer)
* **PC**
* **PSTATE** (status register, CPSR replacement)

Special ones:

* **X30 = LR**
* **X31** is either **SP** or a zero register depending on context.

---

# ğŸŸ¢ **Summary (Super Easy)**

### âœ” R0â€“R12 â†’ normal registers

### âœ” R13 â†’ SP

### âœ” R14 â†’ LR

### âœ” R15 â†’ PC

### âœ” CPSR â†’ Status + flags

### âœ” SPSR â†’ Exception return state

### âœ” Banked registers â†’ different versions per mode

### âœ” ARMv8 â†’ X0â€“X30 (64-bit)

---

If you want, I can also explain:

âœ… **ARM pipeline (3-stage / 5-stage)**
âœ… **Thumb vs ARM instruction set**
âœ… **Examples of register usage in assembly**
âœ… **Diagram of ARM register banking**

Just tell me!



**No â€” every mode does *not* get its own copy of *all* registers.**

ARM gives **each mode its own copy of only *some* registers**, not all.

This is *exactly* what â€œbanked registersâ€ means.

Letâ€™s explain this cleanly.

---

# âœ… **Do all modes get all registers privately?**

**NO.**
Only a *small subset* of registers are banked (private) per mode.

Most registers are **shared** between modes.

---

# ğŸ§  **ARM Register Sharing vs Banking (Easy Hinglish)**

## âœ” **Shared Registers**

These registers are **same for all modes**:

```
R0 â€“ R7   (Always shared)
```

Meaning:
If User mode writes to R1, Supervisor mode will also see that value.

---

## âœ” **Partially Banked Registers**

Some registers have multiple versions **per mode**:

```
R8 â€“ R12   (Shared for most modes)
           BUT FIQ mode gets its own copies
```

---

## âœ” **Fully Banked Registers** (per mode)

Some registers have **private copies for each mode**:

```
R13 (SP)  â€“ Each mode has its own SP
R14 (LR)  â€“ Each mode has its own LR
SPSR      â€“ Each mode except User/System has its own SPSR
```

So IRQ mode has:

* R13_irq (SP used only by IRQ)
* R14_irq (LR used only by IRQ)
* SPSR_irq

FIQ mode has:

* R8_fiq â€“ R14_fiq (its own FAST registers)
* SPSR_fiq

Supervisor has:

* R13_svc
* R14_svc
* SPSR_svc

And so on.

---

# ğŸ”µ **Complete Table â€” Who Gets What?**

| Mode             | Private SP | Private LR | Private R8â€“R12? | Private SPSR |
| ---------------- | ---------- | ---------- | --------------- | ------------ |
| User             | âŒ          | âŒ          | âŒ               | âŒ            |
| System           | âŒ          | âŒ          | âŒ               | âŒ            |
| Supervisor (SVC) | âœ”          | âœ”          | âŒ               | âœ”            |
| IRQ              | âœ”          | âœ”          | âŒ               | âœ”            |
| FIQ              | âœ”          | âœ”          | âœ”**(R8â€“R12)**   | âœ”            |
| Abort (ABT)      | âœ”          | âœ”          | âŒ               | âœ”            |
| Undefined (UND)  | âœ”          | âœ”          | âŒ               | âœ”            |

---

# â­ Final Summary (Super Easy Hinglish)

### âŒ Not all registers are banked

### âœ” Only some registers get private copies

### âœ” R0â€“R7 = shared by all modes

### âœ” R8â€“R12 = only FIQ mode gets private copies

### âœ” R13 (SP) and R14 (LR) = every privileged mode gets its own

### âœ” SPSR = every privileged mode has one

---

# ğŸ§  Mental Model

Think of ARM as having:

* **Shared registers** (everyone uses same ones)
* **Private drawers** (some modes have their own drawer for certain registers)

FIQ gets the most drawers â†’ fastest interrupt handling.

---

If you want, I can also draw a **diagram** showing all banked registers and shared registers visually.



ğŸ§  List of ARM CPU modes (ARMv7-A)

User (usr)

FIQ (fiq)

IRQ (irq)

Supervisor / SVC

Abort / ABT

Undefined / UND

System / sys
